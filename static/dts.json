[{"filePath":"file:///node_modules/ts-graphviz/package.json","content":"{\"name\":\"ts-graphviz\",\"types\":\"lib/ts-graphviz.d.ts\"}"},{"filePath":"file:///node_modules/ts-graphviz/lib/adapter.d.ts","content":"export * from '@ts-graphviz/adapter';\n"},{"filePath":"file:///node_modules/ts-graphviz/lib/ast.d.ts","content":"export * from '@ts-graphviz/ast';\n"},{"filePath":"file:///node_modules/ts-graphviz/lib/attribute.d.ts","content":"import { Attribute } from '@ts-graphviz/common';\nexport declare const attribute: Attribute.keys;\n"},{"filePath":"file:///node_modules/ts-graphviz/lib/from-dot.d.ts","content":"import { ConvertToModelOptions, ParseOptions } from '@ts-graphviz/ast';\nimport { EdgeModel, NodeModel, RootGraphModel, SubgraphModel } from '@ts-graphviz/common';\nexport interface FromDotOptions<T extends 'Dot' | 'Graph' | 'Node' | 'Edge' | 'Subgraph'> {\n    parse?: ParseOptions<T>;\n    convert?: ConvertToModelOptions;\n}\nexport declare function fromDot(dot: string, options?: FromDotOptions<'Dot' | 'Graph'>): RootGraphModel;\nexport declare function fromDot(dot: string, options?: FromDotOptions<'Node'>): NodeModel;\nexport declare function fromDot(dot: string, options?: FromDotOptions<'Edge'>): EdgeModel;\nexport declare function fromDot(dot: string, options?: FromDotOptions<'Subgraph'>): SubgraphModel;\n"},{"filePath":"file:///node_modules/ts-graphviz/lib/model-factory-builder.d.ts","content":"import { ModelsContext } from '@ts-graphviz/common';\nimport { ModelFactory } from './types.js';\nexport declare function ModelFactoryBuilder(this: ModelsContext, directed: boolean, strictMode: boolean): ModelFactory;\nexport declare function createModelFactories(strict: boolean, context?: ModelsContext): Readonly<{\n    digraph: ModelFactory;\n    graph: ModelFactory;\n}>;\n"},{"filePath":"file:///node_modules/ts-graphviz/lib/model-factory.d.ts","content":"import { ModelsContext } from '@ts-graphviz/common';\nimport { ModelFactories, ModelFactoriesWithStrict } from './types.js';\nexport declare const digraph: import('./types.js').ModelFactory;\nexport declare const graph: import('./types.js').ModelFactory;\nexport declare const strict: ModelFactories;\nexport declare function withContext(models: Partial<ModelsContext>): ModelFactoriesWithStrict;\n"},{"filePath":"file:///node_modules/ts-graphviz/lib/to-dot.d.ts","content":"import { ConvertFromModelOptions, PrintOptions } from '@ts-graphviz/ast';\nimport { DotObjectModel } from '@ts-graphviz/common';\nexport interface ToDotOptions {\n    convert?: ConvertFromModelOptions;\n    print?: PrintOptions;\n}\nexport declare function toDot(model: DotObjectModel, options?: ToDotOptions): string;\n"},{"filePath":"file:///node_modules/ts-graphviz/lib/ts-graphviz.d.ts","content":"export * from '@ts-graphviz/common';\nexport * from '@ts-graphviz/core';\nexport * from './types.js';\nexport * from './attribute.js';\nexport * from './model-factory.js';\nexport * from './from-dot.js';\nexport * from './to-dot.js';\n"},{"filePath":"file:///node_modules/ts-graphviz/lib/types.d.ts","content":"import { GraphAttributesObject, RootGraphModel } from '@ts-graphviz/common';\nexport interface ModelFactory {\n    (id?: string, attributes?: GraphAttributesObject, callback?: (g: RootGraphModel) => void): RootGraphModel;\n    (attributes?: GraphAttributesObject, callback?: (g: RootGraphModel) => void): RootGraphModel;\n    (id?: string, callback?: (g: RootGraphModel) => void): RootGraphModel;\n    (callback?: (g: RootGraphModel) => void): RootGraphModel;\n}\nexport interface ModelFactories {\n    digraph: ModelFactory;\n    graph: ModelFactory;\n}\nexport interface ModelFactoriesWithStrict extends ModelFactories {\n    strict: ModelFactories;\n}\n"},{"filePath":"file:///node_modules/@ts-graphviz/adapter/package.json","content":"{\"name\":\"@ts-graphviz/adapter\",\"types\":\"./lib/node.d.ts\"}"},{"filePath":"file:///node_modules/@ts-graphviz/adapter/./lib/browser.d.ts","content":"/**\n * @module @ts-graphviz/adapter\n */\nexport type Options = any;\n/**\n * Execute the Graphviz dot command and make a Stream of the results.\n */\nexport declare function toStream(dot: string, options?: Options): never;\n/**\n * Execute the Graphviz dot command and output the results to a file.\n */\nexport declare function toFile(dot: string, path: string, options?: Options): never;\n"},{"filePath":"file:///node_modules/@ts-graphviz/adapter/./lib/create-command-and-args.d.ts","content":"import { Layout, Options } from './types.js';\n/**\n * createCommandAndArgs creates a command and an array of arguments, based on the given {@link Options}.\n *\n * @param options Options to create the command and args from.\n * @returns A tuple containing the command and an array of arguments.\n */\nexport declare function createCommandAndArgs<T extends Layout>(options: Options<T>): [command: string, args: string[]];\n"},{"filePath":"file:///node_modules/@ts-graphviz/adapter/./lib/create-command-args.d.ts","content":"import { Attribute, AttributeKey } from '@ts-graphviz/common';\nimport { Layout, Options } from './types.js';\n/**\n * escapeValue is a function that escapes a given Attribute value of a given AttributeKey.\n * It checks the type of the value and adds quotes if the value is of type string and contains whitespace.\n *\n * @param value The value of an Attribute of type T that extends AttributeKey\n * @returns The escaped Attribute value\n */\nexport declare function escapeValue<T extends AttributeKey>(value: Attribute<T>): string;\n/**\n * createCommandArgs is a function that creates command arguments from a given Options object.\n * It reads the properties of the Options object and creates corresponding command line arguments accordingly.\n *\n * @param options The Options object used to create command arguments\n * @returns A generator that yields strings for command arguments\n */\nexport declare function createCommandArgs<T extends Layout>(options: Options<T>): Generator<string>;\n"},{"filePath":"file:///node_modules/@ts-graphviz/adapter/./lib/deno.d.ts","content":"import { Layout, Options } from './types.js';\n/// <reference lib=\"dom\" />\nexport type * from './types.js';\n/**\n * Execute the Graphviz dot command and make a Stream of the results.\n */\nexport declare function toStream<T extends Layout>(dot: string, options?: Options<T>): Promise<ReadableStream<Uint8Array>>;\n/**\n * Execute the Graphviz dot command and output the results to a file.\n */\nexport declare function toFile<T extends Layout>(dot: string, path: string, options?: Options<T>): Promise<void>;\n"},{"filePath":"file:///node_modules/@ts-graphviz/adapter/./lib/node.d.ts","content":"/**\n * @module @ts-graphviz/adapter\n */\nexport type * from './types.js';\nexport * from './to-stream.node.js';\nexport * from './to-file.node.js';\n"},{"filePath":"file:///node_modules/@ts-graphviz/adapter/./lib/to-file.node.d.ts","content":"import { Layout, Options } from './types.js';\n/**\n * Execute the Graphviz dot command and output the results to a file.\n */\nexport declare function toFile<T extends Layout>(dot: string, path: string, options?: Options<T>): Promise<void>;\n"},{"filePath":"file:///node_modules/@ts-graphviz/adapter/./lib/to-stream.node.d.ts","content":"import { Layout, Options } from './types.js';\n/**\n * Execute the Graphviz dot command and make a Stream of the results.\n */\nexport declare function toStream<T extends Layout>(dot: string, options?: Options<T>): Promise<NodeJS.ReadableStream>;\n"},{"filePath":"file:///node_modules/@ts-graphviz/adapter/./lib/types.d.ts","content":"import { $keywords, $keywordsValidation, EdgeAttributesObject, GraphAttributesObject, NodeAttributesObject, SubgraphAttributesObject } from '@ts-graphviz/common';\nexport type Format = Format.values;\nexport declare namespace Format {\n    type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\n    interface $values extends $keywords<'png' | 'svg' | 'json' | 'jpg' | 'pdf' | 'xdot' | 'dot' | 'plain' | 'dot_json'> {\n    }\n    interface $exclude extends $keywordsValidation {\n    }\n}\nexport type Layout = Layout.values;\nexport declare namespace Layout {\n    type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\n    interface $values extends $keywords<'dot' | 'neato' | 'fdp' | 'sfdp' | 'circo' | 'twopi' | 'nop' | 'nop2' | 'osage' | 'patchwork'> {\n    }\n    interface $exclude extends $keywordsValidation {\n    }\n}\n/**\n * NeatoOptions interface provides options for the neato layout.\n * @public\n */\nexport interface NeatoOptions {\n    layout: 'neato';\n    /**\n     * Sets no-op flag in neato.\n     */\n    noop?: number;\n    /**\n     * Reduce graph.\n     */\n    reduce?: boolean;\n}\n/**\n * FdpOptions interface provides options for the fdp layout.\n * @public\n */\nexport interface FdpOptions {\n    layout: 'fdp';\n    /**\n     * Use grid.\n     *\n     * @default true\n     */\n    grid?: boolean;\n    /**\n     * Use old attractive force\n     *\n     * @default true\n     */\n    oldAttractive?: boolean;\n    /**\n     * Set number of iterations.\n     */\n    iterations?: number;\n    /**\n     * Set unscaled factor\n     */\n    unscaledFactor?: number;\n    /**\n     * Set overlap expansion factor.\n     */\n    overlapExpansionFactor?: number;\n    /**\n     * Set temperature.\n     */\n    temperature?: number;\n}\n/**\n * This interface describes an optional parameter called \"layout\" which is used to set a layout engine.\n * The default value for this parameter is 'dot', and it must be an option of the Layout type,\n * excluding 'neato' and 'fdp'.\n * @public\n */\nexport interface OtherOptions {\n    /**\n     * Set layout engine.\n     *\n     * @default 'dot'\n     */\n    layout?: Exclude<Layout, 'neato' | 'fdp'>;\n}\n/**\n * This interface represents the CommonOptions for setting output format.\n * @public\n */\nexport interface CommonOptions {\n    /**\n     * Set output format.\n     *\n     * @default 'svg'\n     */\n    format?: Format;\n    /**\n     * If true, set level of message suppression (=1).\n     *\n     * @default true\n     */\n    suppressWarnings?: boolean;\n    /**\n     * Path of graphviz dot command.\n     */\n    dotCommand?: string;\n    attributes?: {\n        /**\n         * Set edge attribute.\n         */\n        edge?: EdgeAttributesObject;\n        /**\n         * Set node attribute.\n         */\n        node?: NodeAttributesObject;\n        /**\n         * Set graph attribute.\n         */\n        graph?: GraphAttributesObject & SubgraphAttributesObject;\n    };\n    /**\n     * Scale input\n     */\n    scale?: number;\n    /**\n     * Use external library.\n     */\n    library?: string[];\n    /**\n     * Invert y coordinate in output.\n     */\n    y?: boolean;\n}\nexport type Options<T extends Layout = Layout> = CommonOptions & (T extends 'neato' ? NeatoOptions : T extends 'fdp' ? FdpOptions : OtherOptions);\n"},{"filePath":"file:///node_modules/@ts-graphviz/common/package.json","content":"{\"name\":\"@ts-graphviz/common\",\"types\":\"lib/common.d.ts\"}"},{"filePath":"file:///node_modules/@ts-graphviz/common/lib/common.d.ts","content":"/**\r\n * @hidden\r\n */\r\nexport declare type $keywords<T extends string> = {\r\n    [key in T]: key;\r\n};\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport declare interface $keywordsValidation extends $keywords<`${string} ${string}` | `${string}\\n${string}` | `${string}\\t${string}`> {\r\n}\r\n\r\n/**\r\n * A double with an optional prefix `'+'`.\r\n *\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/addDouble/ addDouble}\r\n * @group Attribute Types\r\n */\r\nexport declare type AddDouble = `+${Double}`;\r\n\r\n/**\r\n * A point with an optional prefix `'+'`.\r\n *\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/addPoint/ addPoint}\r\n * @group Attribute Types\r\n */\r\nexport declare type AddPoint = `+${Point}`;\r\n\r\n/**\r\n * The examples above show a set of commonly used arrow shapes.\r\n *\r\n * There is a grammar of arrow shapes which can be used to describe a collection of 3,111,696 arrow\r\n * combinations of the 42 variations of the primitive set of 11 arrows.\r\n *\r\n * @see {@link https://graphviz.org/docs/attr-types/arrowType/ arrowType}\r\n * @group Attribute Types\r\n */\r\nexport declare type ArrowType = ArrowType.aname | `${ArrowType.aname}${ArrowType.aname}`;\r\n\r\n/** @hidden */\r\nexport declare namespace ArrowType {\r\n    export type shape = keyof $shape;\r\n    export interface $shape extends $keywords<'box' | 'crow' | 'curve' | 'icurve' | 'diamond' | 'dot' | 'inv' | 'none' | 'normal' | 'tee' | 'vee'> {\r\n    }\r\n    export type side = 'l' | 'r';\r\n    export type modifiers = side | 'o' | `o${side}`;\r\n    export type aname = shape | `${modifiers}${shape}`;\r\n}\r\n\r\n/**\r\n * ASTType is an enumeration of the different types of nodes that can be found in an AST(Abstract Syntax Tree ).\r\n * @group Models\r\n */\r\nexport declare type ASTType = 'Literal' | 'Dot' | 'Graph' | 'Attribute' | 'Comment' | 'AttributeList' | 'NodeRef' | 'NodeRefGroup' | 'Edge' | 'Node' | 'Subgraph';\r\n\r\n/**\r\n * This type represents an Attribute, which is a key-value mapping of an {@link AttributeKey} to a value.\r\n *\r\n * @param T The {@link AttributeKey} to be mapped to a value.\r\n * @group Attribute\r\n */\r\nexport declare type Attribute<T extends AttributeKey> = Attribute.types[T];\r\n\r\nexport declare namespace Attribute {\r\n    export type keys = Omit<$keys, keyof $exclude | symbol | number>;\r\n    export type types = Omit<$types, keyof $exclude | symbol | number>;\r\n    /** @hidden */\r\n    export interface $keys extends $keywords<AttributeKey> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n    /**\r\n     * @group Attribute\r\n     */\r\n    export interface $keys {\r\n        /**\r\n         * Factor damping force motions.\r\n         * On each iteration, a nodes movement is limited to this factor of its potential motion.\r\n         * By being less than 1.0, the system tends to ``cool'', thereby preventing cycling.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/Damping/ Node, Edge and Graph Attributes#Damping}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 0.99\r\n         * @graphvizMinimum 0\r\n         * @graphvizNotes neato only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        Damping: 'Damping';\r\n        /**\r\n         * Spring constant used in virtual physical model.\r\n         * It roughly corresponds to an ideal edge length (in inches), in that increasing K tends to increase the distance between nodes.\r\n         * Note that the edge attribute {@link len} can be used to override this value for adjacent nodes.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/K/ Node, Edge and Graph Attributes#K}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 0.3\r\n         * @graphvizMinimum 0\r\n         * @graphvizNotes sfdp, fdp only\r\n         * @graphvizUsedBy GC\r\n         * @category Attribute\r\n         */\r\n        K: 'K';\r\n        /**\r\n         * Hyperlinks incorporated into device-dependent output.\r\n         * At present, used in ps2, cmap, i*map and svg formats.\r\n         * For all these formats, URLs can be attached to nodes, edges and clusters.\r\n         * URL attributes can also be attached to the root graph in ps2, cmap and i*map formats.\r\n         * This serves as the base URL for relative URLs in the former, and as the default image map file in the latter.\r\n         *\r\n         * For svg, cmapx and imap output, the active area for a node is its visible image.\r\n         * For example, an unfilled node with no drawn boundary will only be active on its label.\r\n         * For other output, the active area is its bounding box.\r\n         * The active area for a cluster is its bounding box.\r\n         * For edges, the active areas are small circles where the edge contacts its head and tail nodes.\r\n         * In addition, for svg, cmapx and imap, the active area includes a thin polygon approximating the edge.\r\n         * The circles may overlap the related node, and the edge URL dominates.\r\n         * If the edge has a label, this will also be active. Finally, if the edge has a head or tail label, this will also be active.\r\n         *\r\n         * Note that, for edges, the attributes {@link headURL}, {@link tailURL}, {@link labelURL} and {@link edgeURL} allow control of various parts of an edge.\r\n         * Also note that, if active areas of two edges overlap, it is unspecified which area dominates.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/URL/ Node, Edge and Graph Attributes#URL}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault <none>\r\n         * @graphvizNotes svg, postscript, map only\r\n         * @graphvizUsedBy ENGC\r\n         * @category Attribute\r\n         */\r\n        URL: 'URL';\r\n        /**\r\n         * A string in the {@link https://graphviz.org/_pages/doc/info/output.html#d:xdot xdot format} specifying an arbitrary background.\r\n         * During rendering, the canvas is first filled as described in the {@link bgcolor} attribute.\r\n         * Then, if _background is defined, the graphics operations described in the string are performed on the canvas.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/_background/ Node, Edge and Graph Attributes#_background}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault <none>\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        _background: '_background';\r\n        /**\r\n         * Indicates the preferred area for a node or empty cluster when laid out by patchwork.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/area/ Node, Edge and Graph Attributes#area}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 1\r\n         * @graphvizMinimum >0\r\n         * @graphvizNotes patchwork only\r\n         * @graphvizUsedBy NC\r\n         * @category Attribute\r\n         */\r\n        area: 'area';\r\n        /**\r\n         * Style of arrowhead on the head node of an edge.\r\n         * This will only appear if the {@link dir} attribute is \"forward\" or \"both\".\r\n         *\r\n         * See the {@link https://graphviz.org/doc/info/attrs.html#undir_note limitation}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/arrowhead/ Node, Edge and Graph Attributes#arrowhead}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/arrowType/ arrowType}\r\n         * @graphvizDefault normal\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        arrowhead: 'arrowhead';\r\n        /**\r\n         * Multiplicative scale factor for arrowheads.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/arrowsize/ Node, Edge and Graph Attributes#arrowsize}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 1\r\n         * @graphvizMinimum 0\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        arrowsize: 'arrowsize';\r\n        /**\r\n         * Style of arrowhead on the tail node of an edge.\r\n         * This will only appear if the {@link dir} attribute is \"back\" or \"both\".\r\n         *\r\n         * See the {@link https://graphviz.org/doc/info/attrs.html#undir_note limitation}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/arrowtail/ Node, Edge and Graph Attributes#arrowtail}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/arrowType/ arrowType}\r\n         * @graphvizDefault normal\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        arrowtail: 'arrowtail';\r\n        /**\r\n         * Bounding box of drawing in points.\r\n         *\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/rect/ rect}\r\n         * @graphvizNotes write only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        bb: 'bb';\r\n        /**\r\n         * When attached to the root graph, this color is used as the background for entire canvas.\r\n         * When a cluster attribute, it is used as the initial background for the cluster.\r\n         * If a cluster has a filled {@link style}, the cluster's {@link fillcolor} will overlay the background color.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/bgcolor/ Node, Edge and Graph Attributes#bgcolor}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/color/ color}/{@link https://graphviz.org/docs/attr-types/color/List colorList}\r\n         * @graphvizDefault <none>\r\n         * @graphvizUsedBy GC\r\n         * @category Attribute\r\n         */\r\n        bgcolor: 'bgcolor';\r\n        /**\r\n         * If true, the drawing is centered in the output canvas.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/center/ Node, Edge and Graph Attributes#center}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault FALSE\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        center: 'center';\r\n        /**\r\n         * Specifies the character encoding used when interpreting string input as a text label.\r\n         * The default value is \"UTF-8\". The other legal value is \"iso-8859-1\" or, equivalently, \"Latin1\".\r\n         * The charset attribute is case-insensitive.\r\n         * Note that if the character encoding used in the input does not match the charset value, the resulting output may be very strange.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/charset/ Node, Edge and Graph Attributes#charset}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"UTF-8\"\r\n         * @graphvizUsedBy G\r\n         *\r\n         * @category Attribute\r\n         */\r\n        charset: 'charset';\r\n        /**\r\n         * Classnames to attach to the node, edge, graph, or cluster's SVG element.\r\n         * Combine with stylesheet for styling SVG output using CSS classnames.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/class/ class}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy ENCG\r\n         */\r\n        class: 'class';\r\n        /**\r\n         * Mode used for handling clusters.\r\n         * If clusterrank is \"local\", a subgraph whose name begins with \"cluster\" is given special treatment.\r\n         * The subgraph is laid out separately, and then integrated as a unit into its parent graph, with a bounding rectangle drawn about it.\r\n         * If the cluster has a label parameter, this label is displayed within the rectangle.\r\n         * Note also that there can be clusters within clusters.\r\n         * At present, the modes \"global\" and \"none\" appear to be identical, both turning off the special cluster processing.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/clusterrank/ Node, Edge and Graph Attributes#clusterrank}\r\n         * @graphvizType {@link https://graphviz.org/_pages/doc/info/attrs.html#k:clusterMode clusterMode}\r\n         * @graphvizDefault local\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        clusterrank: 'clusterrank';\r\n        /**\r\n         * Basic drawing color for graphics, not text.\r\n         * For the latter, use the fontcolor attribute.\r\n         *\r\n         * For edges, the value can either be a single color or a colorList.\r\n         * In the latter case, if colorList has no fractions, the edge is drawn using parallel splines or lines, one for each color in the list, in the order given.\r\n         * The head arrow, if any, is drawn using the first color in the list, and the tail arrow, if any, the second color.\r\n         * This supports the common case of drawing opposing edges, but using parallel splines instead of separately routed multiedges.\r\n         * If any fraction is used, the colors are drawn in series, with each color being given roughly its specified fraction of the edge.\r\n         * For example, the graph\r\n         *\r\n         * ```dot\r\n         *  digraph G {\r\n         *    a -> b [dir=both color=\"red:blue\"]\r\n         *    c -> d [dir=none color=\"green:red;0.25:blue\"]\r\n         *  }\r\n         * ```\r\n         *\r\n         * yields\r\n         *\r\n         * ![colorlist](https://graphviz.org/_pages/doc/info/colorlist.gif)\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/color/ Node, Edge and Graph Attributes#color}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/color/ color}/{@link https://graphviz.org/docs/attr-types/color/List colorList}\r\n         * @graphvizDefault black\r\n         * @graphvizUsedBy ENC\r\n         * @category Attribute\r\n         */\r\n        color: 'color';\r\n        /**\r\n         * This attribute specifies a color scheme namespace.\r\n         * If defined, it specifies the context for interpreting color names.\r\n         * In particular, if a color value has form \"xxx\" or \"//xxx\", then the color xxx will be evaluated according to the current color scheme.\r\n         * If no color scheme is set, the standard X11 naming is used.\r\n         * For example, if colorscheme=bugn9, then color=7 is interpreted as \"/bugn9/7\".\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/colorscheme/ Node, Edge and Graph Attributes#colorscheme}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy ENCG\r\n         * @category Attribute\r\n         */\r\n        colorscheme: 'colorscheme';\r\n        /**\r\n         * Comments are inserted into output.\r\n         * Device-dependent\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/comment/ Node, Edge and Graph Attributes#comment}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy ENG\r\n         * @category Attribute\r\n         */\r\n        comment: 'comment';\r\n        /**\r\n         * If true, allow edges between clusters. (See {@link lhead} and {@link ltail} below.)\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/compound/ Node, Edge and Graph Attributes#compound}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault FALSE\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        compound: 'compound';\r\n        /**\r\n         * If true, use edge concentrators.\r\n         * This merges multiedges into a single edge and causes partially parallel edges to share part of their paths.\r\n         * The latter feature is not yet available outside of dot.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/concentrate/ Node, Edge and Graph Attributes#concentrate}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault FALSE\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        concentrate: 'concentrate';\r\n        /**\r\n         * If false, the edge is not used in ranking the nodes.\r\n         * For example, in the graph\r\n         *\r\n         * ```graphviz\r\n         *  digraph G {\r\n         *    a -> c;\r\n         *    a -> b;\r\n         *    b -> c [constraint=false];\r\n         *  }\r\n         * ```\r\n         *\r\n         * the edge `b -> c` does not add a constraint during rank assignment, so the only constraints are that a be above b and c, yielding the graph:\r\n         *\r\n         * ![constraint](https://graphviz.org/_pages/doc/info/constraint.gif)\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/constraint/ Node, Edge and Graph Attributes#constraint}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault TRUE\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        constraint: 'constraint';\r\n        /**\r\n         * If true, attach edge label to edge by a 2-segment polyline, underlining the label, then going to the closest point of spline.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/decorate/ Node, Edge and Graph Attributes#decorate}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault FALSE\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        decorate: 'decorate';\r\n        /**\r\n         * This specifies the distance between nodes in separate connected components.\r\n         * If set too small, connected components may overlap. Only applicable if {@link pack}=false.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/defaultdist/ Node, Edge and Graph Attributes#defaultdist}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 1+(avg. len)*sqrt(|V|)\r\n         * @graphvizMinimum epsilon\r\n         * @graphvizNotes neato only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        defaultdist: 'defaultdist';\r\n        /**\r\n         * Set the number of dimensions used for the layout.\r\n         * The maximum value allowed is 10.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/dim/ Node, Edge and Graph Attributes#dim}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/int/ int}\r\n         * @graphvizDefault 2\r\n         * @graphvizMinimum 2\r\n         * @graphvizNotes sfdp, fdp, neato only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        dim: 'dim';\r\n        /**\r\n         * Set the number of dimensions used for rendering.\r\n         * The maximum value allowed is 10.\r\n         * If both dimen and dim are set, the latter specifies the dimension used for layout, and the former for rendering.\r\n         * If only dimen is set, this is used for both layout and rendering dimensions.\r\n         *\r\n         * Note that, at present, all aspects of rendering are 2D.\r\n         * This includes the shape and size of nodes, overlap removal, and edge routing.\r\n         * Thus, for dimen > 2, the only valid information is the pos attribute of the nodes.\r\n         * All other coordinates will be 2D and, at best, will reflect a projection of a higher-dimensional point onto the plane.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/dimen/ Node, Edge and Graph Attributes#dimen}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/int/ int}\r\n         * @graphvizDefault 2\r\n         * @graphvizMinimum 2\r\n         * @graphvizNotes sfdp, fdp, neato only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        dimen: 'dimen';\r\n        /**\r\n         * Set edge type for drawing arrowheads.\r\n         * This indicates which ends of the edge should be decorated with an arrowhead.\r\n         * The actual style of the arrowhead can be specified using the {@link arrowhead} and {@link arrowtail} attributes.\r\n         * See {@link https://graphviz.org/doc/info/attrs.html#undir_note limitation}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/dir/ Node, Edge and Graph Attributes#dir}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/dirType/ dirType}\r\n         * @graphvizDefault \"forward(directed) none(undirected)\"\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        dir: 'dir';\r\n        /**\r\n         * Only valid when {@link mode}=\"ipsep\".\r\n         * If true, constraints are generated for each edge in the largest (heuristic) directed acyclic subgraph such that the edge must point downwards.\r\n         * If \"hier\", generates level constraints similar to those used with {@link mode}=\"hier\".\r\n         * The main difference is that, in the latter case, only these constraints are involved, so a faster solver can be used.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/diredgeconstraints/ Node, Edge and Graph Attributes#diredgeconstraints}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}/{@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault FALSE\r\n         * @graphvizNotes neato only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        diredgeconstraints: 'diredgeconstraints';\r\n        /**\r\n         * Distortion factor for {@link shape}=polygon.\r\n         * Positive values cause top part to be larger than bottom; negative values do the opposite.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/distortion/ Node, Edge and Graph Attributes#distortion}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault -100\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        distortion: 'distortion';\r\n        /**\r\n         * This specifies the expected number of pixels per inch on a display device.\r\n         * For bitmap output, this guarantees that text rendering will be done more accurately, both in size and in placement.\r\n         * For SVG output, it is used to guarantee that the dimensions in the output correspond to the correct number of points or inches.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/dpi/ Node, Edge and Graph Attributes#dpi}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault \"96.0 0.0\"\r\n         * @graphvizNotes svg, bitmap output only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        dpi: 'dpi';\r\n        /**\r\n         * If **edgeURL** is defined, this is the link used for the non-label parts of an edge.\r\n         * This value overrides any {@link URL} defined for the edge.\r\n         * Also, this value is used near the head or tail node unless overridden by a {@link headURL} or {@link tailURL} value, respectively.\r\n         * See {@link https://graphviz.org/doc/info/attrs.html#undir_note limitation}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/edgeURL/ Node, Edge and Graph Attributes#edgeURL}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg, map only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        edgeURL: 'edgeURL';\r\n        /**\r\n         * Synonym for {@link edgeURL}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/edgehref/ Node, Edge and Graph Attributes#edgehref}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg, map only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        edgehref: 'edgehref';\r\n        /**\r\n         * If the edge has a {@link URL} or {@link edgeURL} attribute, this attribute determines which window of the browser is used for the URL attached to the non-label part of the edge.\r\n         * Setting it to \"_graphviz\" will open a new window if it doesn't already exist, or reuse it if it does.\r\n         * If undefined, the value of the {@link target} is used.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/edgetarget/ Node, Edge and Graph Attributes#edgetarget}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault <none>\r\n         * @graphvizNotes svg, map only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        edgetarget: 'edgetarget';\r\n        /**\r\n         * Tooltip annotation attached to the non-label part of an edge.\r\n         * This is used only if the edge has a {@link URL} or {@link edgeURL} attribute.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/edgetooltip/ Node, Edge and Graph Attributes#edgetooltip}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg, cmap only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        edgetooltip: 'edgetooltip';\r\n        /**\r\n         * Terminating condition. If the length squared of all energy gradients are < **epsilon**, the algorithm stops.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/epsilon/ Node, Edge and Graph Attributes#epsilon}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault .0001 * # nodes(mode == KK) .0001(mode == major)\r\n         * @graphvizNotes neato only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        epsilon: 'epsilon';\r\n        /**\r\n         * Margin used around polygons for purposes of spline edge routing.\r\n         * The interpretation is the same as given for {@link sep}.\r\n         * This should normally be strictly less than {@link sep}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/esep/ Node, Edge and Graph Attributes#esep}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/addDouble/ addDouble}/{@link https://graphviz.org/_pages/doc/info/attrs.html#k:addPoint addPoint}\r\n         * @graphvizDefault 3\r\n         * @graphvizNotes not dot\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        esep: 'esep';\r\n        /**\r\n         * Color used to fill the background of a node or cluster assuming {@link style}=filled, or a filled arrowhead.\r\n         * If fillcolor is not defined, {@link color} is used. (For clusters, if color is not defined, {@link bgcolor} is used.)\r\n         * If this is not defined, the default is used, except for {@link shape}=point or when the output format is MIF, which use black by default.\r\n         *\r\n         * If the value is a {@link colorList}, a gradient fill is used.\r\n         * By default, this is a linear fill; setting style=radial will cause a radial fill.\r\n         * At present, only two colors are used. If the second color (after a colon) is missing, the default color is used for it.\r\n         * See also the {@link gradientangle} attribute for setting the gradient angle.\r\n         *\r\n         * Note that a cluster inherits the root graph's attributes if defined.\r\n         * Thus, if the root graph has defined a **fillcolor**, this will override a **color** or **bgcolor** attribute set for the cluster.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/fillcolor/ Node, Edge and Graph Attributes#fillcolor}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/color/ color}/{@link https://graphviz.org/docs/attr-types/color/List colorList}\r\n         * @graphvizDefault \"lightgrey(nodes) black(clusters)\"\r\n         * @graphvizUsedBy NEC\r\n         * @category Attribute\r\n         */\r\n        fillcolor: 'fillcolor';\r\n        /**\r\n         * If `false`, the size of a node is determined by smallest width and height needed to contain its label and image,\r\n         * if any, with a {@link margin} specified by the margin attribute.\r\n         * The width and height must also be at least as large as the sizes specified by the {@link width} and {@link height} attributes,\r\n         * which specify the minimum values for these parameters.\r\n         *\r\n         * If `true`, the node size is specified by the values of the {@link width} and {@link height} attributes only and is not expanded to contain the text label.\r\n         * There will be a warning if the label (with margin) cannot fit within these limits.\r\n         *\r\n         * If the {@link fixedsize} attribute is set to shape, the {@link width} and {@link height} attributes also determine the size of the node shape,\r\n         * but the label can be much larger. Both the label and shape sizes are used when avoiding node overlap,\r\n         * but all edges to the node ignore the label and only contact the node shape. No warning is given if the label is too large.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/fixedsize/ Node, Edge and Graph Attributes#fixedsize}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}/string\r\n         * @graphvizDefault FALSE\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        fixedsize: 'fixedsize';\r\n        /**\r\n         * Color used for text.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/fontcolor/ Node, Edge and Graph Attributes#fontcolor}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/color/ color}\r\n         * @graphvizDefault black\r\n         * @graphvizUsedBy ENGC\r\n         * @category Attribute\r\n         */\r\n        fontcolor: 'fontcolor';\r\n        /**\r\n         * Font used for text.\r\n         * This very much depends on the output format and, for non-bitmap output such as PostScript or SVG,\r\n         * the availability of the font when the graph is displayed or printed.\r\n         * As such, it is best to rely on font faces that are generally available,\r\n         * such as Times-Roman, Helvetica or Courier.\r\n         *\r\n         * How font names are resolved also depends on the underlying library that handles font name resolution.\r\n         * If Graphviz was built using the fontconfig library, the latter library will be used to search for the font.\r\n         * See the commands **fc-list**, **fc-match** and the other fontconfig commands for how names are resolved and which fonts are available.\r\n         * Other systems may provide their own font package, such as Quartz for OS X.\r\n         *\r\n         * Note that various font attributes, such as weight and slant, can be built into the font name.\r\n         * Unfortunately, the syntax varies depending on which font system is dominant. Thus, using fontname=\"times bold italic\" will produce a bold, slanted Times font using Pango, the usual main font library.\r\n         * Alternatively, fontname=\"times:italic\" will produce a slanted Times font from fontconfig, while fontname=\"times-bold\" will resolve to a bold Times using Quartz.\r\n         * You will need to ascertain which package is used by your Graphviz system and refer to the relevant documentation.\r\n         *\r\n         * If Graphviz is not built with a high-level font library, fontname will be considered the name of a Type 1 or True Type font file.\r\n         * If you specify fontname=schlbk, the tool will look for a file named schlbk.ttf or schlbk.pfa or schlbk.pfb in one of the directories specified by the {@link fontpath} attribute.\r\n         * The lookup does support various aliases for the common fonts.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/fontname/ Node, Edge and Graph Attributes#fontname}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"Times-Roman\"\r\n         * @graphvizUsedBy ENGC\r\n         * @category Attribute\r\n         */\r\n        fontname: 'fontname';\r\n        /**\r\n         * Allows user control of how basic fontnames are represented in SVG output.\r\n         * If fontnames is undefined or \"svg\", the output will try to use known SVG fontnames.\r\n         * For example, the default font \"Times-Roman\" will be mapped to the basic SVG font \"serif\".\r\n         * This can be overridden by setting fontnames to \"ps\" or \"gd\". In the former case, known PostScript font names such as \"Times-Roman\" will be used in the output.\r\n         * In the latter case, the fontconfig font conventions are used. Thus, \"Times-Roman\" would be treated as \"Nimbus Roman No9 L\".\r\n         * These last two options are useful with SVG viewers that support these richer fontname spaces.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/fontnames/ Node, Edge and Graph Attributes#fontnames}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        fontnames: 'fontnames';\r\n        /**\r\n         * Directory list used by libgd to search for bitmap fonts if Graphviz was not built with the fontconfig library.\r\n         * If **fontpath** is not set, the environment variable DOTFONTPATH is checked.\r\n         * If that is not set, GDFONTPATH is checked.\r\n         * If not set, libgd uses its compiled-in font path.\r\n         * Note that fontpath is an attribute of the root graph.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/fontpath/ Node, Edge and Graph Attributes#fontpath}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault system-dependent\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        fontpath: 'fontpath';\r\n        /**\r\n         * Font size, {@link https://graphviz.org/doc/info/attrs.html in points}, used for text.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/fontsize/ Node, Edge and Graph Attributes#fontsize}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 14\r\n         * @graphvizMinimum 1\r\n         * @graphvizUsedBy ENGC\r\n         * @category Attribute\r\n         */\r\n        fontsize: 'fontsize';\r\n        /**\r\n         * If true, all {@link xlabel} attributes are placed,\r\n         * even if there is some overlap with nodes or other labels.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/forcelabels/ Node, Edge and Graph Attributes#forcelabels}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault TRUE\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        forcelabels: 'forcelabels';\r\n        /**\r\n         * If a gradient fill is being used, this determines the angle of the fill.\r\n         * For linear fills, the colors transform along a line specified by the angle and the center of the object.\r\n         * For radial fills, a value of zero causes the colors to transform radially from the center; for non-zero values,\r\n         * the colors transform from a point near the object's periphery as specified by the value.\r\n         *\r\n         * If unset, the default angle is 0.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/gradientangle/ Node, Edge and Graph Attributes#gradientangle}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/int/ int}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy NCG\r\n         * @category Attribute\r\n         */\r\n        gradientangle: 'gradientangle';\r\n        /**\r\n         * If the end points of an edge belong to the same group, i.e.,\r\n         * have the same group attribute, parameters are set to avoid crossings and keep the edges straight.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/group/ Node, Edge and Graph Attributes#group}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        group: 'group';\r\n        /**\r\n         * If **headURL** is defined, it is output as part of the head label of the edge.\r\n         * Also, this value is used near the head node, overriding any {@link URL} value.\r\n         * See {@link https://graphviz.org/doc/info/attrs.html#undir_note limitation}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/headURL/ Node, Edge and Graph Attributes#headURL}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg, map only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        headURL: 'headURL';\r\n        /**\r\n         * Position of an edge's head label, {@link https://graphviz.org/doc/info/attrs.html in points}.\r\n         * The position indicates the center of the label.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/head_lp/ Node, Edge and Graph Attributes#head_lp}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/point/ point}\r\n         * @graphvizNotes write only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        head_lp: 'head_lp';\r\n        /**\r\n         * If true, the head of an edge is clipped to the boundary of the head node; otherwise,\r\n         * the end of the edge goes to the center of the node, or the center of a port, if applicable.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/headclip/ Node, Edge and Graph Attributes#headclip}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault TRUE\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        headclip: 'headclip';\r\n        /**\r\n         * Synonym for {@link headURL}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/headhref/ Node, Edge and Graph Attributes#headhref}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg, map only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        headhref: 'headhref';\r\n        /**\r\n         * Text label to be placed near head of edge.\r\n         * See {@link https://graphviz.org/doc/info/attrs.html#undir_note limitation}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/headlabel/ Node, Edge and Graph Attributes#headlabel}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/lblString/ lblString}\r\n         * @graphvizDefault center\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        headlabel: 'headlabel';\r\n        /**\r\n         * Indicates where on the head node to attach the head of the edge.\r\n         * In the default case, the edge is aimed towards the center of the node, and then clipped at the node boundary.\r\n         * See {@link https://graphviz.org/doc/info/attrs.html#undir_note limitation}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/headport/ Node, Edge and Graph Attributes#headport}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/portPos/ portPos}\r\n         * @graphvizDefault <none>\r\n         * @graphvizNotes svg, map only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        headport: 'headport';\r\n        /**\r\n         * If the edge has a {@link headURL}, this attribute determines which window of the browser is used for the URL.\r\n         * Setting it to \"_graphviz\" will open a new window if it doesn't already exist, or reuse it if it does.\r\n         * If undefined, the value of the {@link target} is used.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/headtarget/ Node, Edge and Graph Attributes#headtarget}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg, cmap only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        headtarget: 'headtarget';\r\n        /**\r\n         * Tooltip annotation attached to the head of an edge.\r\n         * This is used only if the edge has a {@link headURL} attribute.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/headtooltip/ Node, Edge and Graph Attributes#headtooltip}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault 0.5\r\n         * @graphvizMinimum 0.02\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        headtooltip: 'headtooltip';\r\n        /**\r\n         * Height of node, in inches.\r\n         * This is taken as the initial, minimum height of the node.\r\n         * If {@link fixedsize} is true, this will be the final height of the node.\r\n         * Otherwise, if the node label requires more height to fit, the node's **height** will be increased to contain the label.\r\n         * Note also that, if the output format is dot, the value given to height will be the final value.\r\n         *\r\n         * If the node shape is regular, the width and height are made identical.\r\n         * In this case, if either the width or the height is set explicitly, that value is used.\r\n         * In this case, if both the width or the height are set explicitly, the maximum of the two values is used.\r\n         * If neither is set explicitly, the minimum of the two default values is used.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/height/ Node, Edge and Graph Attributes#height}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg, postscript, map only\r\n         * @graphvizUsedBy GCNE\r\n         * @category Attribute\r\n         */\r\n        height: 'height';\r\n        /**\r\n         * Synonym for {@link URL}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/href/ Node, Edge and Graph Attributes#href}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg, postscript, map only\r\n         * @graphvizUsedBy GCNE\r\n         * @category Attribute\r\n         */\r\n        href: 'href';\r\n        /**\r\n         * Allows the graph author to provide an id for graph objects which is to be included in the output.\r\n         * Normal \"\\N\", \"\\E\", \"\\G\" substitutions are applied.\r\n         * If provided, it is the responsibility of the provider to keep its values sufficiently unique for its intended downstream use.\r\n         * Note, in particular, that \"\\E\" does not provide a unique id for multi-edges.\r\n         * If no id attribute is provided, then a unique internal id is used.\r\n         * However, this value is unpredictable by the graph writer.\r\n         * An externally provided id is not used internally.\r\n         *\r\n         * If the graph provides an id attribute, this will be used as a prefix for internally generated attributes.\r\n         * By making these distinct, the user can include multiple image maps in the same document.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/id/ Node, Edge and Graph Attributes#id}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        id: 'id';\r\n        /**\r\n         * Gives the name of a file containing an image to be displayed inside a node.\r\n         * The image file must be in one of the recognized {@link https://graphviz.org/docs/outputs/ formats},\r\n         * typically JPEG, PNG, GIF, BMP, SVG or Postscript, and be able to be converted into the desired output format.\r\n         *\r\n         * The file must contain the image size information.\r\n         * This is usually trivially true for the bitmap formats.\r\n         * For PostScript, the file must contain a line starting with %%BoundingBox: followed by four integers specifying the lower left x and y coordinates and the upper right x and y coordinates of the bounding box for the image, the coordinates being in points.\r\n         * An SVG image file must contain width and height attributes, typically as part of the svg element.\r\n         * The values for these should have the form of a floating point number, followed by optional units, e.g.,\r\n         * width=\"76pt\". Recognized units are in, px, pc, pt, cm and mm for inches, pixels, picas, points, centimeters and millimeters, respectively.\r\n         * The default unit is points.\r\n         *\r\n         * Unlike with the {@link shapefile} attribute, the image is treated as node content rather than the entire node. In particular, an image can be contained in a node of any shape, not just a rectangle.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/image/ Node, Edge and Graph Attributes#image}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        image: 'image';\r\n        /**\r\n         * Specifies a list of directories in which to look for image files as specified by the {@link image} attribute or using the IMG element in {@link https://graphviz.org/doc/info/shapes.html HTML-like labels}.\r\n         * The string should be a list of (absolute or relative) pathnames, each separated by a semicolon (for Windows) or a colon (all other OS).\r\n         * The first directory in which a file of the given name is found will be used to load the image.\r\n         * If imagepath is not set, relative pathnames for the image file will be interpreted with respect to the current working directory.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/imagepath/ Node, Edge and Graph Attributes#imagepath}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        imagepath: 'imagepath';\r\n        /**\r\n         * Attribute controlling how an image is positioned within its containing node.\r\n         * This only has an effect when the image is smaller than the containing node.\r\n         * The default is to be centered both horizontally and vertically.\r\n         * Valid values:\r\n         *\r\n         * |    |                               |\r\n         * |----|-------------------------------|\r\n         * | tl | Top Left                      |\r\n         * | tc | Top Centered                  |\r\n         * | tr | Top Right                     |\r\n         * | ml | Middle Left                   |\r\n         * | mc | Middle Centered (the default) |\r\n         * | mr | Middle Right                  |\r\n         * | bl | Bottom Left                   |\r\n         * | bc | Bottom Centered               |\r\n         * | br | Bottom Right                  |\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/imagepos/ Node, Edge and Graph Attributes#imagepos}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"mc\"\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        imagepos: 'imagepos';\r\n        /**\r\n         * Attribute controlling how an image fills its containing node.\r\n         * In general, the image is given its natural size, (cf. {@link dpi}), and the node size is made large enough to contain its image, its label, its margin, and its peripheries.\r\n         * Its width and height will also be at least as large as its minimum {@link width} and {@link height}.\r\n         * If, however, fixedsize=true, the width and height attributes specify the exact size of the node.\r\n         *\r\n         * During rendering, in the default case (imagescale=false), the image retains its natural size. If imagescale=true, the image is uniformly scaled (i.e., its aspect ratio is preserved) to fit inside the node. At least one dimension of the image will be as large as possible given the size of the node. When imagescale=width, the width of the image is scaled to fill the node width. The corresponding property holds when imagescale=height. When imagescale=both, both the height and the width are scaled separately to fill the node.\r\n         *\r\n         * In all cases, if a dimension of the image is larger than the corresponding dimension of the node,\r\n         * that dimension of the image is scaled down to fit the node.\r\n         * As with the case of expansion, if imagescale=true, width and height are scaled uniformly.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/imagescale/ Node, Edge and Graph Attributes#imagescale}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}/string\r\n         * @graphvizDefault FALSE\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        imagescale: 'imagescale';\r\n        /**\r\n         * For layout algorithms that support initial input positions (specified by the pos attribute),\r\n         * this attribute can be used to appropriately scale the values.\r\n         * By default, fdp and neato interpret the x and y values of pos as being in inches.\r\n         * (**NOTE**: neato -n(2) treats the coordinates as being in points, being the unit used by the layout algorithms for the pos attribute.)\r\n         * Thus, if the graph has pos attributes in points, one should set inputscale=72.\r\n         * This can also be set on the command line using the {@link https://graphviz.org/doc/info/command.html#-s -s flag} flag.\r\n         *\r\n         * If not set, no scaling is done and the units on input are treated as inches.\r\n         * A value of 0 is equivalent to inputscale=72.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/inputscale/ Node, Edge and Graph Attributes#inputscale}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault <none>\r\n         * @graphvizNotes fdp, neato only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        inputscale: 'inputscale';\r\n        /**\r\n         * Text label attached to objects.\r\n         * If a node's {@link shape} is record, then the label can have a {@link https://graphviz.org/doc/info/shapes.html special format} which describes the record layout.\r\n         *\r\n         * Note that a node's default label is \"\\N\", so the node's name or ID becomes its label.\r\n         * Technically, a node's name can be an HTML string but this will not mean that the node's label will be interpreted as an {@link https://graphviz.org/doc/info/shapes.html HTML-like} label.\r\n         * This is because the node's actual label is an ordinary string, which will be replaced by the raw bytes stored in the node's name.\r\n         * To get an HTML-like label, the label attribute value itself must be an HTML string.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/label/ Node, Edge and Graph Attributes#label}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/lblString/ lblString}\r\n         * @graphvizDefaultValu\r\n         * \"\\N\" (nodes)\r\n         * \"\" (otherwise)\r\n         * @graphvizUsedBy ENGC\r\n         * @category Attribute\r\n         */\r\n        label: 'label';\r\n        /**\r\n         * If **labelURL** is defined, this is the link used for the label of an edge.\r\n         * This value overrides any {@link URL} defined for the edge.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/labelURL/ Node, Edge and Graph Attributes#labelURL}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg, map only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        labelURL: 'labelURL';\r\n        /**\r\n         * The value indicates whether to treat a node whose name has the form |edgelabel|* as a special node representing an edge label.\r\n         * The default (0) produces no effect.\r\n         * If the attribute is set to 1, sfdp uses a penalty-based method to make that kind of node close to the center of its neighbor.\r\n         * With a value of 2, sfdp uses a penalty-based method to make that kind of node close to the old center of its neighbor.\r\n         * Finally, a value of 3 invokes a two-step process of overlap removal and straightening.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/label_scheme/ Node, Edge and Graph Attributes#label_scheme}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/int/ int}\r\n         * @graphvizDefault 0\r\n         * @graphvizMinimum 0\r\n         * @graphvizNotes sfdp only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        label_scheme: 'label_scheme';\r\n        /**\r\n         * This, along with {@link labeldistance}, determine where the headlabel (taillabel) are placed with respect to the head (tail) in polar coordinates.\r\n         * The origin in the coordinate system is the point where the edge touches the node.\r\n         * The ray of 0 degrees goes from the origin back along the edge, parallel to the edge at the origin.\r\n         *\r\n         * The angle, in degrees, specifies the rotation from the 0 degree ray, with positive angles moving counterclockwise and negative angles moving clockwise.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/labelangle/ Node, Edge and Graph Attributes#labelangle}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault -25\r\n         * @graphvizMinimum -180\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        labelangle: 'labelangle';\r\n        /**\r\n         * Multiplicative scaling factor adjusting the distance that the headlabel(taillabel) is from the head(tail) node.\r\n         * The default distance is 10 points.\r\n         * See {@link labelangle} for more details.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/labeldistance/ Node, Edge and Graph Attributes#labeldistance}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 1\r\n         * @graphvizMinimum 0\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        labeldistance: 'labeldistance';\r\n        /**\r\n         * If true, allows edge labels to be less constrained in position.\r\n         * In particular, it may appear on top of other edges.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/labelfloat/ Node, Edge and Graph Attributes#labelfloat}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault FALSE\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        labelfloat: 'labelfloat';\r\n        /**\r\n         * Color used for headlabel and taillabel.\r\n         * If not set, defaults to edge's fontcolor.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/labelfontcolor/ Node, Edge and Graph Attributes#labelfontcolor}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/color/ color}\r\n         * @graphvizDefault black\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        labelfontcolor: 'labelfontcolor';\r\n        /**\r\n         * Font used for headlabel and taillabel.\r\n         * If not set, defaults to edge's fontname.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/labelfontname/ Node, Edge and Graph Attributes#labelfontname}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"Times-Roman\"\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        labelfontname: 'labelfontname';\r\n        /**\r\n         * Font size, {@link https://graphviz.org/doc/info/attrs.html in points}, used for headlabel and taillabel.\r\n         * If not set, defaults to edge's fontsize.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/labelfontsize/ Node, Edge and Graph Attributes#labelfontsize}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 14\r\n         * @graphvizMinimum 1\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        labelfontsize: 'labelfontsize';\r\n        /**\r\n         * Synonym for {@link labelURL}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/labelhref/ Node, Edge and Graph Attributes#labelhref}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg, map only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        labelhref: 'labelhref';\r\n        /**\r\n         * Justification for cluster labels.\r\n         * If \"r\", the label is right-justified within bounding rectangle; if \"l\", left-justified; else the label is centered.\r\n         * Note that a subgraph inherits attributes from its parent.\r\n         * Thus, if the root graph sets **labeljust** to \"l\", the subgraph inherits this value.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/labeljust/ Node, Edge and Graph Attributes#labeljust}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"c\"\r\n         * @graphvizUsedBy GC\r\n         * @category Attribute\r\n         */\r\n        labeljust: 'labeljust';\r\n        /**\r\n         * Vertical placement of labels for nodes, root graphs and clusters.\r\n         *\r\n         * For graphs and clusters, only \"t\" and \"b\" are allowed, corresponding to placement at the top and bottom, respectively.\r\n         * By default, root graph labels go on the bottom and cluster labels go on the top.\r\n         * Note that a subgraph inherits attributes from its parent.\r\n         * Thus, if the root graph sets {@link labelloc} to \"b\", the subgraph inherits this value.\r\n         *\r\n         * For nodes, this attribute is used only when the height of the node is larger than the height of its label.\r\n         * If labelloc is set to \"t\", \"c\", or \"b\", the label is aligned with the top, centered, or aligned with the bottom of the node, respectively.\r\n         * In the default case, the label is vertically centered.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/labelloc/ Node, Edge and Graph Attributes#labelloc}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault\r\n         * \"t\"(clusters)\r\n         * \"b\"(root graphs)\r\n         * \"c\"(nodes)\r\n         * @graphvizUsedBy NGC\r\n         * @category Attribute\r\n         */\r\n        labelloc: 'labelloc';\r\n        /**\r\n         * If the edge has a {@link URL} or {@link labelURL} attribute, this attribute determines which window of the browser is used for the URL attached to the label.\r\n         * Setting it to \"_graphviz\" will open a new window if it doesn't already exist, or reuse it if it does.\r\n         * If undefined, the value of the {@link target} is used.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/labeltarget/ Node, Edge and Graph Attributes#labeltarget}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault <none>\r\n         * @graphvizNotes svg, map only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        labeltarget: 'labeltarget';\r\n        /**\r\n         * Tooltip annotation attached to label of an edge.\r\n         * This is used only if the edge has a {@link URL} or {@link labelURL} attribute.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/labeltooltip/ Node, Edge and Graph Attributes#labeltooltip}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg, cmap only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        labeltooltip: 'labeltooltip';\r\n        /**\r\n         * If true, the graph is rendered in landscape mode.\r\n         * Synonymous with {@link rotate rotate=90} or {@link orientation orientation=landscape}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/landscape/ Node, Edge and Graph Attributes#landscape}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault FALSE\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        landscape: 'landscape';\r\n        /**\r\n         * Specifies layers in which the node, edge or cluster is present.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/layer/ Node, Edge and Graph Attributes#layer}\r\n         * @graphvizType {@link https://graphviz.org/_pages/doc/info/attrs.html#k:layerRange layerRange}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy ENC\r\n         * @category Attribute\r\n         */\r\n        layer: 'layer';\r\n        /**\r\n         * Specifies the separator characters used to split an attribute of type {@link layerRange} into a list of ranges.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/layerlistsep/ Node, Edge and Graph Attributes#layerlistsep}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        layerlistsep: 'layerlistsep';\r\n        /**\r\n         * Specifies a linearly ordered list of layer names attached to the graph The graph is then output in separate layers.\r\n         * Only those components belonging to the current output layer appear.\r\n         * For more information, see the page {@link https://graphviz.org/faq/#FaqOverlays How to use drawing layers (overlays)}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/layers/ Node, Edge and Graph Attributes#layers}\r\n         * @graphvizType {@link https://graphviz.org/_pages/doc/info/attrs.html#k:layerList layerList}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        layers: 'layers';\r\n        /**\r\n         * Selects a list of layers to be emitted.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/layerselect/ Node, Edge and Graph Attributes#layerselect}\r\n         * @graphvizType {@link https://graphviz.org/_pages/doc/info/attrs.html#k:layerRange layerRange}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        layerselect: 'layerselect';\r\n        /**\r\n         * Specifies the separator characters used to split the {@link layers} attribute into a list of layer names.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/layersep/ Node, Edge and Graph Attributes#layersep}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \" :\\t\"\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        layersep: 'layersep';\r\n        /**\r\n         * Specifies the name of the layout algorithm to use, such as \"dot\" or \"neato\".\r\n         * Normally, graphs should be kept independent of a type of layout.\r\n         * In some cases, however, it can be convenient to embed the type of layout desired within the graph.\r\n         * For example, a graph containing position information from a layout might want to record what the associated layout algorithm was.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/layout/ Node, Edge and Graph Attributes#layout}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        layout: 'layout';\r\n        /**\r\n         * Preferred edge length, in inches.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/len/ Node, Edge and Graph Attributes#len}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault\r\n         * 1.0(neato)\r\n         * 0.3(fdp)\r\n         * @graphvizNotes fdp, neato only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        len: 'len';\r\n        /**\r\n         * Number of levels allowed in the multilevel scheme.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/levels/ Node, Edge and Graph Attributes#levels}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/int/ int}\r\n         * @graphvizDefault MAXINT\r\n         * @graphvizMinimum 0\r\n         * @graphvizNotes sfdp only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        levels: 'levels';\r\n        /**\r\n         * Specifies strictness of level constraints in neato when {@link mode}=\"ipsep\" or \"hier\".\r\n         * Larger positive values mean stricter constraints, which demand more separation between levels.\r\n         * On the other hand, negative values will relax the constraints by allowing some overlap between the levels.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/levelsgap/ Node, Edge and Graph Attributes#levelsgap}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 0\r\n         * @graphvizNotes neato only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        levelsgap: 'levelsgap';\r\n        /**\r\n         * Logical head of an edge.\r\n         * When {@link compound} is true, if **lhead** is defined and is the name of a cluster containing the real head,\r\n         * the edge is clipped to the boundary of the cluster.\r\n         * See the {@link https://graphviz.org/doc/info/attrs.html#undir_note limitation}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/lhead/ Node, Edge and Graph Attributes#lhead}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        lhead: 'lhead';\r\n        /**\r\n         * Height of graph or cluster label, in inches.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/lheight/ Node, Edge and Graph Attributes#lheight}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizNotes write only\r\n         * @graphvizUsedBy GC\r\n         * @category Attribute\r\n         */\r\n        lheight: 'lheight';\r\n        /**\r\n         * Label position, {@link https://graphviz.org/doc/info/attrs.html in points}.\r\n         * The position indicates the center of the label.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/lp/ Node, Edge and Graph Attributes#lp}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/point/ point}\r\n         * @graphvizNotes write only\r\n         * @graphvizUsedBy EGC\r\n         * @category Attribute\r\n         */\r\n        lp: 'lp';\r\n        /**\r\n         * Logical tail of an edge.\r\n         * When {@link compound} is true, if **ltail** is defined and is the name of a cluster containing the real tail, the edge is clipped to the boundary of the cluster.\r\n         * See the {@link https://graphviz.org/doc/info/attrs.html#undir_note limitation}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/ltail/ Node, Edge and Graph Attributes#ltail}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        ltail: 'ltail';\r\n        /**\r\n         * Width of graph or cluster label, in inches.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/lwidth/ Node, Edge and Graph Attributes#lwidth}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizNotes write only\r\n         * @graphvizUsedBy GC\r\n         * @category Attribute\r\n         */\r\n        lwidth: 'lwidth';\r\n        /**\r\n         * For graphs, this sets x and y margins of canvas, in inches.\r\n         * If the margin is a single double, both margins are set equal to the given value.\r\n         *\r\n         * Note that the margin is not part of the drawing but just empty space left around the drawing.\r\n         * It basically corresponds to a translation of drawing, as would be necessary to center a drawing on a page.\r\n         * Nothing is actually drawn in the margin.\r\n         * To actually extend the background of a drawing, see the {@link pad} attribute.\r\n         *\r\n         * For clusters, this specifies the space between the nodes in the cluster and the cluster bounding box.\r\n         * By default, this is 8 points.\r\n         *\r\n         * For nodes, this attribute specifies space left around the node's label.\r\n         * By default, the value is 0.11,0.055.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/margin/ Node, Edge and Graph Attributes#margin}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}/{@link https://graphviz.org/docs/attr-types/point/ point}\r\n         * @graphvizDefault <device-dependent>\r\n         * @graphvizUsedBy NCG\r\n         * @category Attribute\r\n         */\r\n        margin: 'margin';\r\n        /**\r\n         * Sets the number of iterations used.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/maxiter/ Node, Edge and Graph Attributes#maxiter}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/int/ int}\r\n         * @graphvizDefault\r\n         * 100 * # nodes(mode == KK)\r\n         * 200(mode == major)\r\n         * 600(fdp)\r\n         * @graphvizNotes fdp, neato only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        maxiter: 'maxiter';\r\n        /**\r\n         * Multiplicative scale factor used to alter the MinQuit (default = 8) and MaxIter (default = 24) parameters used during crossing minimization.\r\n         * These correspond to the number of tries without improvement before quitting and the maximum number of iterations in each pass.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/mclimit/ Node, Edge and Graph Attributes#mclimit}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 1\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        mclimit: 'mclimit';\r\n        /**\r\n         * Specifies the minimum separation between all nodes.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/mindist/ Node, Edge and Graph Attributes#mindist}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 1\r\n         * @graphvizMinimum 0\r\n         * @graphvizNotes circo only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        mindist: 'mindist';\r\n        /**\r\n         * Minimum edge length (rank difference between head and tail).\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/minlen/ Node, Edge and Graph Attributes#minlen}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/int/ int}\r\n         * @graphvizDefault 1\r\n         * @graphvizMinimum 0\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        minlen: 'minlen';\r\n        /**\r\n         * Technique for optimizing the layout.\r\n         * For neato, if **mode** is \"major\", neato uses stress majorization.\r\n         * If **mode** is \"KK\", neato uses a version of the gradient descent method.\r\n         * The only advantage to the latter technique is that it is sometimes appreciably faster for small (number of nodes < 100) graphs.\r\n         * A significant disadvantage is that it may cycle.\r\n         *\r\n         * There are two experimental modes in neato, \"hier\", which adds a top-down directionality similar to the layout used in dot, and \"ipsep\",\r\n         * which allows the graph to specify minimum vertical and horizontal distances between nodes. (See the {@link sep} attribute.)\r\n         *\r\n         * For sfdp, the default **mode** is \"spring\", which corresponds to using a spring-electrical model.\r\n         * Setting **mode** to \"maxent\" causes a similar model to be run but one that also takes into account edge lengths specified by the \"len\" attribute.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/mode/ Node, Edge and Graph Attributes#mode}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault major\r\n         * @graphvizNotes neato only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        mode: 'mode';\r\n        /**\r\n         * This value specifies how the distance matrix is computed for the input graph.\r\n         * The distance matrix specifies the ideal distance between every pair of nodes.\r\n         * neato attemps to find a layout which best achieves these distances.\r\n         * By default, it uses the length of the shortest path, where the length of each edge is given by its {@link len} attribute.\r\n         * If **model** is \"circuit\", neato uses the circuit resistance model to compute the distances.\r\n         * This tends to emphasize clusters.\r\n         * If **model** is \"subset\", neato uses the subset model.\r\n         * This sets the edge length to be the number of nodes that are neighbors of exactly one of the end points, and then calculates the shortest paths.\r\n         * This helps to separate nodes with high degree.\r\n         *\r\n         * For more control of distances, one can use model=mds.\r\n         * In this case, the {@link len} of an edge is used as the ideal distance between its vertices.\r\n         * A shortest path calculation is only used for pairs of nodes not connected by an edge.\r\n         * Thus, by supplying a complete graph, the input can specify all of the relevant distances.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/model/ Node, Edge and Graph Attributes#model}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault shortpath\r\n         * @graphvizNotes neato only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        model: 'model';\r\n        /**\r\n         * If Graphviz is built with MOSEK defined, mode=ipsep and mosek=true, the Mosek software (<www.mosek.com>) is use to solve the ipsep constraints.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/mosek/ Node, Edge and Graph Attributes#mosek}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault FALSE\r\n         * @graphvizNotes neato only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        mosek: 'mosek';\r\n        /**\r\n         * The original ranking algorithm in dot is recursive on clusters.\r\n         * This can produce fewer ranks and a more compact layout, but sometimes at the cost of a head node being place on a higher rank than the tail node.\r\n         * It also assumes that a node is not constrained in separate, incompatible subgraphs.\r\n         * For example, a node cannot be in a cluster and also be constrained by rank=same with a node not in the cluster.\r\n         *\r\n         * If newrank=true, the ranking algorithm does a single global ranking, ignoring clusters.\r\n         * This allows nodes to be subject to multiple constraints.\r\n         * Rank constraints will usually take precedence over edge constraints.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/newrank/ Node, Edge and Graph Attributes#newrank}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault FALSE\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        newrank: 'newrank';\r\n        /**\r\n         * In dot, this specifies the minimum space between two adjacent nodes in the same rank, in inches.\r\n         *\r\n         * For other layouts, this affects the spacing between loops on a single node, or multiedges between a pair of nodes.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/nodesep/ Node, Edge and Graph Attributes#nodesep}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 0.25\r\n         * @graphvizMinimum 0.02\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        nodesep: 'nodesep';\r\n        /**\r\n         * By default, the justification of multi-line labels is done within the largest context that makes sense.\r\n         * Thus, in the label of a polygonal node, a left-justified line will align with the left side of the node (shifted by the prescribed {@link margin}).\r\n         * In record nodes, left-justified line will line up with the left side of the enclosing column of fields.\r\n         * If **nojustify** is \"true\", multi-line labels will be justified in the context of itself.\r\n         * For example, if the attribute is set, the first label line is long, and the second is shorter and left-justified, the second will align with the left-most character in the first line, regardless of how large the node might be.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/nojustify/ Node, Edge and Graph Attributes#nojustify}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault FALSE\r\n         * @graphvizUsedBy GCNE\r\n         * @category Attribute\r\n         */\r\n        nojustify: 'nojustify';\r\n        /**\r\n         * If set, normalize coordinates of final layout so that the first point is at the origin, and then rotate the layout so that the angle of the first edge is specified by the value of normalize in degrees.\r\n         * If normalize is not a number, it is evaluated as a bool, with true corresponding to 0 degrees.\r\n         * **NOTE**: Since the attribute is evaluated first as a number, 0 and 1 cannot be used for false and true.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/normalize/ Node, Edge and Graph Attributes#normalize}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}/{@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault FALSE\r\n         * @graphvizNotes not dot\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        normalize: 'normalize';\r\n        /**\r\n         * By default, the final layout is translated so that the lower-left corner of the bounding box is at the origin.\r\n         * This can be annoying if some nodes are pinned or if the user runs `neato -n`.\r\n         * To avoid this translation, set notranslate to true.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/notranslate/ Node, Edge and Graph Attributes#notranslate}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault FALSE\r\n         * @graphvizNotes neato only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        notranslate: 'notranslate';\r\n        /**\r\n         * Used to set number of iterations in network simplex applications.\r\n         * **nslimit** is used in computing node x coordinates, **nslimit1** for ranking nodes.\r\n         * If defined, # iterations = **nslimit(1)** * # nodes; otherwise, # iterations = MAXINT.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/nslimit/ Node, Edge and Graph Attributes#nslimit}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        nslimit: 'nslimit';\r\n        /**\r\n         * Used to set number of iterations in network simplex applications.\r\n         * **nslimit** is used in computing node x coordinates, **nslimit1** for ranking nodes.\r\n         * If defined, # iterations = **nslimit(1)** * # nodes; otherwise, # iterations = MAXINT.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/nslimit1/ Node, Edge and Graph Attributes#nslimit1}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        nslimit1: 'nslimit1';\r\n        /**\r\n         * Angle, in degrees, used to rotate polygon node shapes. For any number of polygon sides, 0 degrees rotation results in a flat base.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/ordering/ Node, Edge and Graph Attributes#ordering}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy GN\r\n         * @category Attribute\r\n         */\r\n        ordering: 'ordering';\r\n        /**\r\n         * If \"[lL]*\", set graph orientation to landscape Used only if {@link rotate} is not defined.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/orientation/ Node, Edge and Graph Attributes#orientation}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        orientation: 'orientation';\r\n        /**\r\n         * Specify order in which nodes and edges are drawn.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/outputorder/ Node, Edge and Graph Attributes#outputorder}\r\n         * @graphvizType {@link https://graphviz.org/_pages/doc/info/attrs.html#k:outputMode outputMode}\r\n         * @graphvizDefault breadthfirst\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        outputorder: 'outputorder';\r\n        /**\r\n         * Determines if and how node overlaps should be removed.\r\n         * Nodes are first enlarged using the {@link sep} attribute.\r\n         * If \"true\" , overlaps are retained.\r\n         * If the value is \"scale\", overlaps are removed by uniformly scaling in x and y.\r\n         * If the value converts to \"false\", and it is available, Prism, a proximity graph-based algorithm, is used to remove node overlaps.\r\n         * This can also be invoked explicitly with \"overlap=prism\".\r\n         * This technique starts with a small scaling up, controlled by the {@link overlap_scaling} attribute, which can remove a significant portion of the overlap.\r\n         * The prism option also accepts an optional non-negative integer suffix.\r\n         * This can be used to control the number of attempts made at overlap removal.\r\n         * By default, overlap=\"prism\" is equivalent to overlap=\"prism1000\".\r\n         * Setting overlap=\"prism0\" causes only the scaling phase to be run.\r\n         *\r\n         * If Prism is not available, or the version of Graphviz is earlier than 2.28, \"overlap=false\" uses a Voronoi-based technique.\r\n         * This can always be invoked explicitly with \"overlap=voronoi\".\r\n         *\r\n         * If the value is \"scalexy\", x and y are separately scaled to remove overlaps.\r\n         *\r\n         * If the value is \"compress\", the layout will be scaled down as much as possible without introducing any overlaps, obviously assuming there are none to begin with.\r\n         *\r\n         * **N.B.**The remaining allowed values of overlap correspond to algorithms which, at present, can produce bad aspect ratios.\r\n         * In addition, we deprecate the use of the \"ortho*\" and \"portho*\".\r\n         *\r\n         * If the value is \"vpsc\", overlap removal is done as a quadratic optimization to minimize node displacement while removing node overlaps.\r\n         *\r\n         * If the value is \"orthoxy\" or \"orthoyx\", overlaps are moved by optimizing two constraint problems, one for the x axis and one for the y.\r\n         * The suffix indicates which axis is processed first. If the value is \"ortho\", the technique is similar to \"orthoxy\" except a heuristic is used to reduce the bias between the two passes.\r\n         * If the value is \"ortho_yx\", the technique is the same as \"ortho\", except the roles of x and y are reversed.\r\n         * The values \"portho\", \"porthoxy\", \"porthoxy\", and \"portho_yx\" are similar to the previous four, except only pseudo-orthogonal ordering is enforced.\r\n         *\r\n         * If the layout is done by neato with {@link mode}=\"ipsep\", then one can use overlap=ipsep.\r\n         * In this case, the overlap removal constraints are incorporated into the layout algorithm itself.\r\n         * N.B. At present, this only supports one level of clustering.\r\n         *\r\n         * Except for fdp and sfdp, the layouts assume overlap=\"true\" as the default.\r\n         * Fdp first uses a number of passes using a built-in, force-directed technique to try to remove overlaps.\r\n         * Thus, fdp accepts **overlap** with an integer prefix followed by a colon, specifying the number of tries.\r\n         * If there is no prefix, no initial tries will be performed.\r\n         * If there is nothing following a colon, none of the above methods will be attempted.\r\n         * By default, fdp uses overlap=\"9:prism\".\r\n         * Note that overlap=\"true\", overlap=\"0:true\" and overlap=\"0:\" all turn off all overlap removal.\r\n         *\r\n         * By default, sfdp uses `overlap=\"prism0\"`.\r\n         *\r\n         * Except for the Voronoi and prism methods, all of these transforms preserve the orthogonal ordering of the original layout.\r\n         * That is, if the x coordinates of two nodes are originally the same, they will remain the same, and if the x coordinate of one node is originally less than the x coordinate of another, this relation will still hold in the transformed layout.\r\n         * The similar properties hold for the y coordinates.\r\n         * This is not quite true for the \"porth*\" cases.\r\n         * For these, orthogonal ordering is only preserved among nodes related by an edge.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/overlap/ Node, Edge and Graph Attributes#overlap}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}/{@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault TRUE\r\n         * @graphvizNotes not dot\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        overlap: 'overlap';\r\n        /**\r\n         * When overlap=prism, the layout is scaled by this factor, thereby removing a fair amount of node overlap,\r\n         * and making node overlap removal faster and better able to retain the graph's shape.\r\n         *\r\n         * If overlap_scaling is negative, the layout is scaled by -1*overlap_scaling times the average label size.\r\n         * If overlap_scaling is positive, the layout is scaled by overlap_scaling.\r\n         * If overlap_scaling is zero, no scaling is done.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/overlap_scaling/ Node, Edge and Graph Attributes#overlap_scaling}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault -4\r\n         * @graphvizMinimum -1.00E+10\r\n         * @graphvizNotes prism only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        overlap_scaling: 'overlap_scaling';\r\n        /**\r\n         * If true, the overlap removal algorithm will perform a compression pass to reduce the size of the layout.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/overlap_shrink/ Node, Edge and Graph Attributes#overlap_shrink}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault TRUE\r\n         * @graphvizNotes prism only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        overlap_shrink: 'overlap_shrink';\r\n        /**\r\n         * This is true if the value of pack is \"true\" (case-insensitive) or a non-negative integer.\r\n         * If true, each connected component of the graph is laid out separately, and then the graphs are packed together.\r\n         * If pack has an integral value, this is used as the size, in {@link points}, of a margin around each part; otherwise, a default margin of 8 is used.\r\n         * If pack is interpreted as false, the entire graph is laid out together.\r\n         * The granularity and method of packing is influenced by the {@link packmode} attribute.\r\n         *\r\n         * For layouts which always do packing, such a twopi, the **pack** attribute is just used to set the margin.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/pack/ Node, Edge and Graph Attributes#pack}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}/int\r\n         * @graphvizDefault FALSE\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        pack: 'pack';\r\n        /**\r\n         * This indicates how connected components should be packed (cf. {@link https://graphviz.org/docs/attrs/packmode/ packMode}).\r\n         * Note that defining {@link packmode} will automatically turn on packing as though one had set `pack=true`.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/packmode/ Node, Edge and Graph Attributes#packmode}\r\n         * @graphvizType {@link https://graphviz.org/docs/attrs/packmode/ packMode}\r\n         * @graphvizDefault node\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        packmode: 'packmode';\r\n        /**\r\n         * The pad attribute specifies how much, in inches, to extend the drawing area around the minimal area needed to draw the graph.\r\n         * If the pad is a single double, both the x and y pad values are set equal to the given value.\r\n         * This area is part of the drawing and will be filled with the background color, if appropriate.\r\n         *\r\n         * Normally, a small pad is used for aesthetic reasons, especially when a background color is used,\r\n         * to avoid having nodes and edges abutting the boundary of the drawn region.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/pad/ Node, Edge and Graph Attributes#pad}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}/{@link https://graphviz.org/docs/attr-types/point/ point}\r\n         * @graphvizDefault 0.0555 (4 points)\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        pad: 'pad';\r\n        /**\r\n         * Width and height of output pages, in inches.\r\n         * If only a single value is given, this is used for both the width and height.\r\n         *\r\n         * If this is set and is smaller than the size of the layout,\r\n         * a rectangular array of pages of the specified page size is overlaid on the layout,\r\n         * with origins aligned in the lower-left corner, thereby partitioning the layout into pages.\r\n         * The pages are then produced one at a time, in {@link pagedir} order.\r\n         *\r\n         * At present, this only works for PostScript output.\r\n         * For other types of output, one should use another tool to split the output into multiple output files.\r\n         * Or use the {@link viewport} to generate multiple files.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/page/ Node, Edge and Graph Attributes#page}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}/{@link https://graphviz.org/docs/attr-types/point/ point}\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        page: 'page';\r\n        /**\r\n         * If the page attribute is set and applicable, this attribute specifies the order in which the pages are emitted. This is limited to one of the 8 row or column major orders.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/pagedir/ Node, Edge and Graph Attributes#pagedir}\r\n         * @graphvizType {@link https://graphviz.org/_pages/doc/info/attrs.html#k:pagedir pagedir}\r\n         * @graphvizDefault BL\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        pagedir: 'pagedir';\r\n        /**\r\n         * Color used to draw the bounding box around a cluster.\r\n         * If **pencolor** is not defined, {@link color} is used.\r\n         * If this is not defined, {@link bgcolor} is used.\r\n         * If this is not defined, the default is used.\r\n         *\r\n         * Note that a cluster inherits the root graph's attributes if defined.\r\n         * Thus, if the root graph has defined a **pencolor**, this will override a **color** or **bgcolor** attribute set for the cluster.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/pagedir/ Node, Edge and Graph Attributes#pagedir}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/color/ color}\r\n         * @graphvizDefault black\r\n         * @graphvizUsedBy C\r\n         * @category Attribute\r\n         */\r\n        pencolor: 'pencolor';\r\n        /**\r\n         * Specifies the width of the pen, in points, used to draw lines and curves, including the boundaries of edges and clusters.\r\n         * The value is inherited by subclusters.\r\n         * It has no effect on text.\r\n         *\r\n         * Previous to 31 January 2008, the effect of penwidth=W was achieved by including setlinewidth(W) as part of a {@link style} specification.\r\n         * If both are used, penwidth will be used.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/penwidth/ Node, Edge and Graph Attributes#penwidth}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 1\r\n         * @graphvizMinimum 0\r\n         * @graphvizUsedBy CNE\r\n         * @category Attribute\r\n         */\r\n        penwidth: 'penwidth';\r\n        /**\r\n         * Set number of peripheries used in polygonal shapes and cluster boundaries.\r\n         * Note that {@link https://graphviz.org/doc/info/shapes.html#epsf user-defined shapes} are treated as a form of box shape, so the default peripheries value is 1 and the user-defined shape will be drawn in a bounding rectangle.\r\n         * Setting peripheries=0 will turn this off.\r\n         * Also, 1 is the maximum peripheries value for clusters.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/peripheries/ Node, Edge and Graph Attributes#peripheries}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/int/ int}\r\n         * @graphvizDefault\r\n         * shape default(nodes)\r\n         * 1(clusters)\r\n         * @graphvizMinimum 0\r\n         * @graphvizUsedBy NC\r\n         * @category Attribute\r\n         */\r\n        peripheries: 'peripheries';\r\n        /**\r\n         * If true and the node has a pos attribute on input, neato or fdp prevents the node from moving from the input position.\r\n         * This property can also be specified in the pos attribute itself (cf. the {@link https://graphviz.org/docs/attr-types/point/ point} type).\r\n         *\r\n         * Note: Due to an artifact of the implementation, previous to 27 Feb 2014, final coordinates are translated to the origin.\r\n         * Thus, if you look at the output coordinates given in the (x)dot or plain format, pinned nodes will not have the same output coordinates as were given on input.\r\n         * If this is important, a simple workaround is to maintain the coordinates of a pinned node.\r\n         * The vector difference between the old and new coordinates will give the translation, which can then be subtracted from all of the appropriate coordinates.\r\n         *\r\n         * After 27 Feb 2014, this translation can be avoided in neato by setting the {@link notranslate} to TRUE.\r\n         * However, if the graph specifies {@link overlap node overlap removal} or a change in {@link ratio aspect ratio}, node coordinates may still change.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/pin/ Node, Edge and Graph Attributes#pin}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault FALSE\r\n         * @graphvizNotes fdp, neato only\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        pin: 'pin';\r\n        /**\r\n         * Position of node, or spline control points.\r\n         * For nodes, the position indicates the center of the node.\r\n         * On output, the coordinates are in {@link https://graphviz.org/doc/info/attrs.html points}.\r\n         *\r\n         * In neato and fdp, pos can be used to set the initial position of a node.\r\n         * By default, the coordinates are assumed to be in inches.\r\n         * However, the {@link https://graphviz.org/_pages/doc/info/command.html#d:s -s} command line flag can be used to specify different units.\r\n         * As the output coordinates are in points, feeding the output of a graph laid out by a Graphviz program into neato or fdp will almost always require the -s flag.\r\n         *\r\n         * When the {@link https://graphviz.org/_pages/doc/info/command.html#d:n -n} command line flag is used with neato,\r\n         * it is assumed the positions have been set by one of the layout programs, and are therefore in points.\r\n         * Thus, neato -n can accept input correctly without requiring a -s flag and, in fact, ignores any such flag.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/pos/ Node, Edge and Graph Attributes#pos}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/point/ point}/{@link https://graphviz.org/_pages/doc/info/attrs.html#k:smoothType splineType}\r\n         * @graphvizUsedBy EN\r\n         * @category Attribute\r\n         */\r\n        pos: 'pos';\r\n        /**\r\n         * Quadtree scheme to use.\r\n         *\r\n         * A TRUE bool value corresponds to \"normal\"; a FALSE bool value corresponds to \"none\".\r\n         * As a slight exception to the normal interpretation of bool, a value of \"2\" corresponds to \"fast\".\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/quadtree/ Node, Edge and Graph Attributes#quadtree}\r\n         * @graphvizType {@link https://graphviz.org/_pages/doc/info/attrs.html#k:quadType quadType}/{@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault normal\r\n         * @graphvizNotes sfdp only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        quadtree: 'quadtree';\r\n        /**\r\n         * If **quantum** > 0.0, node label dimensions will be rounded to integral multiples of the quantum.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/quantum/ Node, Edge and Graph Attributes#quantum}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 0\r\n         * @graphvizMinimum 0\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        quantum: 'quantum';\r\n        /**\r\n         * Rank constraints on the nodes in a subgraph.\r\n         * If **rank**=\"same\", all nodes are placed on the same rank.\r\n         * If **rank**=\"min\", all nodes are placed on the minimum rank.\r\n         * If **rank**=\"source\", all nodes are placed on the minimum rank, and the only nodes on the minimum rank belong to some subgraph whose rank attribute is \"source\" or \"min\".\r\n         * Analogous criteria hold for rank=\"max\" and rank=\"sink\".\r\n         * (Note: the minimum rank is topmost or leftmost, and the maximum rank is bottommost or rightmost.)\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/rank/ Node, Edge and Graph Attributes#rank}\r\n         * @graphvizType {@link https://graphviz.org/_pages/doc/info/attrs.html#k:rankType rankType}\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy S\r\n         * @category Attribute\r\n         */\r\n        rank: 'rank';\r\n        /**\r\n         * Sets direction of graph layout.\r\n         * For example, if **rankdir**=\"LR\", and barring cycles, an edge T -> H; will go from left to right.\r\n         * By default, graphs are laid out from top to bottom.\r\n         *\r\n         * This attribute also has a side-effect in determining how record nodes are interpreted.\r\n         * See {@link https://graphviz.org/doc/info/shapes.html record shapes}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/rankdir/ Node, Edge and Graph Attributes#rankdir}\r\n         * @graphvizType {@link https://graphviz.org/_pages/doc/info/attrs.html#k:rankdir rankdir}\r\n         * @graphvizDefault TB\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        rankdir: 'rankdir';\r\n        /**\r\n         * In dot, this gives the desired rank separation, in inches.\r\n         * This is the minimum vertical distance between the bottom of the nodes in one rank and the tops of nodes in the next.\r\n         * If the value contains \"equally\", the centers of all ranks are spaced equally apart.\r\n         * Note that both settings are possible, e.g., ranksep = \"1.2 equally\".\r\n         *\r\n         * In twopi, this attribute specifies the radial separation of concentric circles.\r\n         * For twopi, ranksep can also be a list of doubles.\r\n         * The first double specifies the radius of the inner circle; the second double specifies the increase in radius from the first circle to the second; etc.\r\n         * If there are more circles than numbers, the last number is used as the increment for the remainder.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/ranksep/ Node, Edge and Graph Attributes#ranksep}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}/{@link https://graphviz.org/_pages/doc/info/attrs.html#k:doubleList doubleList}\r\n         * @graphvizDefault\r\n         * 0.5(dot)\r\n         * 1.0(twopi)\r\n         * @graphvizMinimum 0.02\r\n         * @graphvizNotes twopi, dot only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        ranksep: 'ranksep';\r\n        /**\r\n         * Sets the aspect ratio (drawing height/drawing width) for the drawing.\r\n         * Note that this is adjusted before the {@link size} attribute constraints are enforced.\r\n         * In addition, the calculations usually ignore the node sizes, so the final drawing size may only approximate what is desired.\r\n         *\r\n         * If **ratio** is numeric, it is taken as the desired aspect ratio.\r\n         * Then, if the actual aspect ratio is less than the desired ratio, the drawing height is scaled up to achieve the desired ratio;\r\n         * if the actual ratio is greater than that desired ratio, the drawing width is scaled up.\r\n         *\r\n         * If **ratio** = \"fill\" and the {@link size} attribute is set, node positions are scaled, separately in both x and y, so that the final drawing exactly fills the specified size.\r\n         * If both {@link size} values exceed the width and height of the drawing, then both coordinate values of each node are scaled up accordingly.\r\n         * However, if either size dimension is smaller than the corresponding dimension in the drawing, one dimension is scaled up so that the final drawing has the same aspect ratio as specified by {@link size}.\r\n         * Then, when rendered, the layout will be scaled down uniformly in both dimensions to fit the given {@link size}, which may cause nodes and text to shrink as well.\r\n         * This may not be what the user wants, but it avoids the hard problem of how to reposition the nodes in an acceptable fashion to reduce the drawing size.\r\n         *\r\n         * If **** = \"compress\" and the {@link size} attribute is set, dot attempts to compress the initial layout to fit in the given size.\r\n         * This achieves a tighter packing of nodes but reduces the balance and symmetry.\r\n         * This feature only works in dot.\r\n         *\r\n         * If **** = \"expand\", the {@link size} attribute is set, and both the width and the height of the graph are less than the value in {@link size},\r\n         * node positions are scaled uniformly until at least one dimension fits {@link size} exactly.\r\n         * Note that this is distinct from using {@link size} as the desired size, as here the drawing is expanded before edges are generated and all node and text sizes remain unchanged.\r\n         *\r\n         * If **** = \"auto\", the {@link page} attribute is set and the graph cannot be drawn on a single page, then {@link size} is set to an ``ideal'' value.\r\n         * In particular, the size in a given dimension will be the smallest integral multiple of the page size in that dimension which is at least half the current size.\r\n         * The two dimensions are then scaled independently to the new size.\r\n         * This feature only works in dot.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/ratio/ Node, Edge and Graph Attributes#ratio}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}/string\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        ratio: 'ratio';\r\n        /**\r\n         * Rectangles for fields of records,\r\n         * {@link https://graphviz.org/doc/info/attrs.html in points}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/rects/ Node, Edge and Graph Attributes#rects}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/rect/ rect}\r\n         * @graphvizNotes write only\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        rects: 'rects';\r\n        /**\r\n         * If true, force polygon to be regular, i.e.,\r\n         * the vertices of the polygon will lie on a circle whose center is the center of the node.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/regular/ Node, Edge and Graph Attributes#regular}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault FALSE\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        regular: 'regular';\r\n        /**\r\n         * If true and there are multiple clusters, run crossing minimization a second time.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/remincross/ Node, Edge and Graph Attributes#remincross}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault TRUE\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        remincross: 'remincross';\r\n        /**\r\n         * The power of the repulsive force used in an extended Fruchterman-Reingold force directed model.\r\n         * Values larger than 1 tend to reduce the warping effect at the expense of less clustering.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/repulsiveforce/ Node, Edge and Graph Attributes#repulsiveforce}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 1\r\n         * @graphvizMinimum 0\r\n         * @graphvizNotes sfdp only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        repulsiveforce: 'repulsiveforce';\r\n        /**\r\n         * This is a synonym for the {@link dpi} attribute.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/resolution/ Node, Edge and Graph Attributes#resolution}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault\r\n         * 96.0\r\n         * 0.0\"\r\n         * @graphvizNotes svg, bitmap output only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        resolution: 'resolution';\r\n        /**\r\n         * This specifies nodes to be used as the center of the layout and the root of the generated spanning tree.\r\n         * As a graph attribute, this gives the name of the node.\r\n         * As a node attribute, it specifies that the node should be used as a central node.\r\n         * In twopi, this will actually be the central node.\r\n         * In circo, the block containing the node will be central in the drawing of its connected component.\r\n         * If not defined, twopi will pick a most central node, and circo will pick a random node.\r\n         *\r\n         * If the root attribute is defined as the empty string, twopi will reset it to name of the node picked as the root node.\r\n         *\r\n         * For twopi, it is possible to have multiple roots, presumably one for each component.\r\n         * If more than one node in a component is marked as the root, twopi will pick one.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/root/ Node, Edge and Graph Attributes#root}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}/{@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault\r\n         * <none>(graphs)\r\n         * false(nodes)\r\n         * @graphvizMinimum\r\n         * @graphvizNotes circo, twopi only\r\n         * @graphvizUsedBy GN\r\n         * @category Attribute\r\n         */\r\n        root: 'root';\r\n        /**\r\n         * If 90, set drawing orientation to landscape.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/rotate/ Node, Edge and Graph Attributes#rotate}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/int/ int}\r\n         * @graphvizDefault 0\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        rotate: 'rotate';\r\n        /**\r\n         * Causes the final layout to be rotated counter-clockwise by the specified number of degrees.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/rotation/ Node, Edge and Graph Attributes#rotation}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 0\r\n         * @graphvizNotes sfdp only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        rotation: 'rotation';\r\n        /**\r\n         * Edges with the same head and the same **samehead** value are aimed at the same point on the head.\r\n         * This has no effect on loops.\r\n         * Each node can have at most 5 unique samehead values.\r\n         * See {@link https://graphviz.org/doc/info/attrs.html#undir_note limitation}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/samehead/ Node, Edge and Graph Attributes#samehead}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        samehead: 'samehead';\r\n        /**\r\n         * Edges with the same tail and the same sametail value are aimed at the same point on the tail.\r\n         * This has no effect on loops.\r\n         * Each node can have at most 5 unique sametail values.\r\n         * See {@link https://graphviz.org/doc/info/attrs.html#undir_note limitation}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/sametail/ Node, Edge and Graph Attributes#sametail}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        sametail: 'sametail';\r\n        /**\r\n         * If the input graph defines the {@link vertices} attribute, and output is dot or xdot, this gives the number of points used for a node whose shape is a circle or ellipse.\r\n         * It plays the same role in neato, when adjusting the layout to avoid overlapping nodes, and in image maps.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/samplepoints/ Node, Edge and Graph Attributes#samplepoints}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/int/ int}\r\n         * @graphvizDefault\r\n         * 8(output)\r\n         * 20(overlap and image maps)\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        samplepoints: 'samplepoints';\r\n        /**\r\n         * If set, after the initial layout, the layout is scaled by the given factors.\r\n         * If only a single number is given, this is used for both factors.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/scale/ Node, Edge and Graph Attributes#scale}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}/{@link https://graphviz.org/docs/attr-types/point/ point}\r\n         * @graphvizNotes not dot\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        scale: 'scale';\r\n        /**\r\n         * During network simplex, maximum number of edges with negative cut values to search when looking for one with minimum cut value.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/searchsize/ Node, Edge and Graph Attributes#searchsize}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/int/ int}\r\n         * @graphvizDefault 30\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        searchsize: 'searchsize';\r\n        /**\r\n         * Specifies margin to leave around nodes when removing node overlap.\r\n         * This guarantees a minimal non-zero distance between nodes.\r\n         *\r\n         * If the attribute begins with a plus sign '+', an additive margin is specified.\r\n         * That is, \"+w,h\" causes the node's bounding box to be increased by w points on the left and right sides, and by h points on the top and bottom.\r\n         * Without a plus sign, the node is scaled by 1 + w in the x coordinate and 1 + h in the y coordinate.\r\n         *\r\n         * If only a single number is given, this is used for both dimensions.\r\n         *\r\n         * If unset but {@link esep} is defined, the sep values will be set to the esep values divided by 0.8. If esep is unset, the default value is used.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/sep/ Node, Edge and Graph Attributes#sep}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/addDouble/ addDouble}/{@link https://graphviz.org/_pages/doc/info/attrs.html#k:addPoint addPoint}\r\n         * @graphvizDefault 4\r\n         * @graphvizNotes not dot\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        sep: 'sep';\r\n        /**\r\n         * Set the shape of a node.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/shape/ Node, Edge and Graph Attributes#shape}\r\n         * @graphvizType {@link https://graphviz.org/_pages/doc/info/attrs.html#k:shape shape}\r\n         * @graphvizDefault ellipse\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        shape: 'shape';\r\n        /**\r\n         * (Deprecated) If defined, shapefile specifies a file containing user-supplied node content.\r\n         * The {@link shape} of the node is set to box.\r\n         * The image in the shapefile must be rectangular.\r\n         * The image formats supported as well as the precise semantics of how the file is used depends on the {@link https://graphviz.org/_pages/doc/info/output.html output format}.\r\n         * For further details, see {@link https://graphviz.org/docs/outputs/ Image Formats} and {@link https://graphviz.org/faq/#ext_image External PostScript files}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/shapefile/ Node, Edge and Graph Attributes#shapefile}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy N\r\n         * @deprecated\r\n         * @category Attribute\r\n         */\r\n        shapefile: 'shapefile';\r\n        /**\r\n         * Print guide boxes in PostScript at the beginning of routesplines if 1, or at the end if 2. (Debugging)\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/showboxes/ Node, Edge and Graph Attributes#showboxes}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/int/ int}\r\n         * @graphvizDefault 0\r\n         * @graphvizMinimum 0\r\n         * @graphvizNotes dot only\r\n         * @graphvizUsedBy ENG\r\n         * @category Attribute\r\n         */\r\n        showboxes: 'showboxes';\r\n        /**\r\n         * Number of sides if {@link shape}=polygon.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/sides/ Node, Edge and Graph Attributes#sides}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/int/ int}\r\n         * @graphvizDefault 4\r\n         * @graphvizMinimum 0\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        sides: 'sides';\r\n        /**\r\n         * Maximum width and height of drawing, in inches.\r\n         * If only a single number is given, this is used for both the width and the height.\r\n         *\r\n         * If defined and the drawing is larger than the given size, the drawing is uniformly scaled down so that it fits within the given size.\r\n         *\r\n         * If size ends in an exclamation point (!), then it is taken to be the desired size. In this case, if both dimensions of the drawing are less than size, the drawing is scaled up uniformly until at least one dimension equals its dimension in size.\r\n         *\r\n         * Note that there is some interaction between the **size** and {@link ratio} attributes.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/size/ Node, Edge and Graph Attributes#size}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}/{@link https://graphviz.org/docs/attr-types/point/ point}\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        size: 'size';\r\n        /**\r\n         * Skew factor for {@link shape}=polygon. Positive values skew top of polygon to right; negative to left.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/skew/ Node, Edge and Graph Attributes#skew}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 0\r\n         * @graphvizMinimum -100\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        skew: 'skew';\r\n        /**\r\n         * Specifies a post-processing step used to smooth out an uneven distribution of nodes.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/smoothing/ Node, Edge and Graph Attributes#smoothing}\r\n         * @graphvizType {@link https://graphviz.org/_pages/doc/info/attrs.html#k:smoothType smoothType}\r\n         * @graphvizDefault \"none\"\r\n         * @graphvizNotes sfdp only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        smoothing: 'smoothing';\r\n        /**\r\n         * If {@link packmode} indicates an array packing, this attribute specifies an insertion order among the components,\r\n         * with smaller values inserted first.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/sortv/ Node, Edge and Graph Attributes#sortv}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/int/ int}\r\n         * @graphvizDefault 0\r\n         * @graphvizMinimum 0\r\n         * @graphvizUsedBy GCN\r\n         * @category Attribute\r\n         */\r\n        sortv: 'sortv';\r\n        /**\r\n         * Controls how, and if, edges are represented.\r\n         * If true, edges are drawn as splines routed around nodes; if false, edges are drawn as line segments.\r\n         * If set to none or \"\", no edges are drawn at all.\r\n         *\r\n         * (1 March 2007) The values line and spline can be used as synonyms for false and true, respectively. In addition, the value polyline specifies that edges should be drawn as polylines.\r\n         *\r\n         * (28 Sep 2010) The value ortho specifies edges should be routed as polylines of axis-aligned segments. Currently, the routing does not handle ports or, in dot, edge labels.\r\n         *\r\n         * (25 Sep 2012) The value curved specifies edges should be drawn as curved arcs.\r\n         *\r\n         * |                                                                                    |                                                                                |\r\n         * |------------------------------------------------------------------------------------|--------------------------------------------------------------------------------|\r\n         * | ![spline_none](https://graphviz.org/_pages/doc/info/spline_none.png)               | ![spline_line](https://graphviz.org/_pages/doc/info/spline_line.png)     |\r\n         * | `splines=none`                                                                     | `splines=line`                                                                 |\r\n         * | `splines=\"\"`                                                                       | `splines=false`                                                                |\r\n         * | ![spline_polyline](https://graphviz.org/_pages/doc/info/spline_polyline.png)       | ![spline_curved](https://graphviz.org/_pages/doc/info/spline_curved.png) |\r\n         * | `splines=polyline`                                                                 | `splines=curved`                                                               |\r\n         * | ![spline_ortho](https://graphviz.org/_pages/doc/info/spline_ortho.png)             | ![spline_spline](https://graphviz.org/_pages/doc/info/spline_spline.png) |\r\n         * | `splines=ortho`                                                                    | `splines=spline`                                                               |\r\n         * |                                                                                    | `splines=true`                                                                 |\r\n         *\r\n         * By default, the attribute is unset. How this is interpreted depends on the layout. For dot,\r\n         * the default is to draw edges as splines. For all other layouts,\r\n         * the default is to draw edges as line segments.\r\n         * Note that for these latter layouts, if splines=\"true\", this requires non-overlapping nodes (cf. {@link overlap}). If fdp is used for layout and splines=\"compound\",\r\n         * then the edges are drawn to avoid clusters as well as nodes.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/splines/ Node, Edge and Graph Attributes#splines}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}/string\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        splines: 'splines';\r\n        /**\r\n         * Parameter used to determine the initial layout of nodes.\r\n         * If unset, the nodes are randomly placed in a unit square with the same seed is always used for the random number generator, so the initial placement is repeatable.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/start/ Node, Edge and Graph Attributes#start}\r\n         * @graphvizType {@link https://graphviz.org/_pages/doc/info/attrs.html#k:startType startType}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes fdp, neato only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        start: 'start';\r\n        /**\r\n         * Set style information for components of the graph.\r\n         * For cluster subgraphs, if style=\"filled\", the cluster box's background is filled.\r\n         *\r\n         * If the default style attribute has been set for a component, an individual component can use style=\"\" to revert to the normal default.\r\n         * For example, if the graph has\r\n         *\r\n         * ```\r\n         * edge [style=\"invis\"]\r\n         * ```\r\n         *\r\n         * making all edges invisible, a specific edge can overrride this via:\r\n         *\r\n         * ```\r\n         * a -> b [style=\"\"]\r\n         * ```\r\n         *\r\n         * Of course, the component can also explicitly set its style attribute to the desired value.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/style/ Node, Edge and Graph Attributes#style}\r\n         * @graphvizType {@link https://graphviz.org/_pages/doc/info/attrs.html#k:style style}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy ENCG\r\n         * @category Attribute\r\n         */\r\n        style: 'style';\r\n        /**\r\n         * A URL or pathname specifying an XML style sheet, used in SVG output.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/stylesheet/ Node, Edge and Graph Attributes#stylesheet}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        stylesheet: 'stylesheet';\r\n        /**\r\n         * If **tailURL** is defined, it is output as part of the tail label of the edge.\r\n         * Also, this value is used near the tail node, overriding any {@link URL} value.\r\n         * See {@link https://graphviz.org/doc/info/attrs.html#undir_note limitation}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/tailURL/ Node, Edge and Graph Attributes#tailURL}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg, map only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        tailURL: 'tailURL';\r\n        /**\r\n         * Position of an edge's tail label, {@link https://graphviz.org/doc/info/attrs.html in points}.\r\n         * The position indicates the center of the label.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/tail_lp/ Node, Edge and Graph Attributes#tail_lp}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/point/ point}\r\n         * @graphvizNotes write only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        tail_lp: 'tail_lp';\r\n        /**\r\n         * If true, the tail of an edge is clipped to the boundary of the tail node; otherwise,\r\n         * the end of the edge goes to the center of the node, or the center of a port, if applicable.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/tailclip/ Node, Edge and Graph Attributes#tailclip}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizDefault TRUE\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        tailclip: 'tailclip';\r\n        /**\r\n         * Synonym for {@link tailURL}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/tailhref/ Node, Edge and Graph Attributes#tailhref}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg, map only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        tailhref: 'tailhref';\r\n        /**\r\n         * Text label to be placed near tail of edge.\r\n         * See {@link https://graphviz.org/doc/info/attrs.html#undir_note limitation}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/taillabel/ Node, Edge and Graph Attributes#taillabel}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/lblString/ lblString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        taillabel: 'taillabel';\r\n        /**\r\n         * Indicates where on the tail node to attach the tail of the edge.\r\n         * See {@link https://graphviz.org/doc/info/attrs.html#undir_note limitation}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/tailport/ Node, Edge and Graph Attributes#tailport}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/portPos/ portPos}\r\n         * @graphvizDefault center\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        tailport: 'tailport';\r\n        /**\r\n         * If the edge has a {@link tailURL}, this attribute determines which window of the browser is used for the URL.\r\n         * Setting it to \"_graphviz\" will open a new window if it doesn't already exist, or reuse it if it does.\r\n         * If undefined, the value of the {@link target} is used.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/tailtarget/ Node, Edge and Graph Attributes#tailtarget}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault <none>\r\n         * @graphvizNotes svg, map only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        tailtarget: 'tailtarget';\r\n        /**\r\n         * Tooltip annotation attached to the tail of an edge.\r\n         * This is used only if the edge has a {@link tailURL} attribute.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/tailtooltip/ Node, Edge and Graph Attributes#tailtooltip}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg, cmap only\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        tailtooltip: 'tailtooltip';\r\n        /**\r\n         * If the object has a URL, this attribute determines which window of the browser is used for the URL.\r\n         * See {@link http://www.w3.org/TR/html401/present/frames.html#adef-target W3C documentation}.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/target/ Node, Edge and Graph Attributes#target}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}/string\r\n         * @graphvizDefault <none>\r\n         * @graphvizNotes svg, map only\r\n         * @graphvizUsedBy ENGC\r\n         * @category Attribute\r\n         */\r\n        target: 'target';\r\n        /**\r\n         * Tooltip annotation attached to the node or edge.\r\n         * If unset, Graphviz will use the object's {@link label} if defined.\r\n         * Note that if the label is a record specification or an HTML-like label, the resulting tooltip may be unhelpful.\r\n         * In this case, if tooltips will be generated, the user should set a tooltip attribute explicitly.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/tooltip/ Node, Edge and Graph Attributes#tooltip}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/escString/ escString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizNotes svg, cmap only\r\n         * @graphvizUsedBy NEC\r\n         * @category Attribute\r\n         */\r\n        tooltip: 'tooltip';\r\n        /**\r\n         * If set explicitly to true or false, the value determines whether or not internal bitmap rendering relies on a truecolor color model or uses a color palette.\r\n         * If the attribute is unset, truecolor is not used unless there is a {@link shapefile} property for some node in the graph.\r\n         * The output model will use the input model when possible.\r\n         *\r\n         * Use of color palettes results in less memory usage during creation of the bitmaps and smaller output files.\r\n         *\r\n         * Usually, the only time it is necessary to specify the truecolor model is if the graph uses more than 256 colors.\r\n         * However, if one uses bgcolor=transparent with a color palette, font antialiasing can show up as a fuzzy white area around characters.\r\n         * Using **truecolor**=true avoids this problem.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/truecolor/ Node, Edge and Graph Attributes#truecolor}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/bool bool}\r\n         * @graphvizNotes bitmap output only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        truecolor: 'truecolor';\r\n        /**\r\n         * If the input graph defines this attribute, the node is polygonal, and output is dot or xdot, this attribute provides the coordinates of the vertices of the node's polygon, in inches.\r\n         * If the node is an ellipse or circle, the {@link samplepoints} attribute affects the output.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/vertices/ Node, Edge and Graph Attributes#vertices}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/pointList pointList}\r\n         * @graphvizNotes write only\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        vertices: 'vertices';\r\n        /**\r\n         * Clipping window on final drawing.\r\n         * Note that this attribute supersedes any {@link size} attribute.\r\n         * The width and height of the viewport specify precisely the final size of the output.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/viewport/ Node, Edge and Graph Attributes#viewport}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/viewPort/ viewPort}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        viewport: 'viewport';\r\n        /**\r\n         * Factor to scale up drawing to allow margin for expansion in Voronoi technique.\r\n         * dim' = (1+2*margin)*dim.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/voro_margin/ Node, Edge and Graph Attributes#voro_margin}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 0.05\r\n         * @graphvizMinimum 0\r\n         * @graphvizNotes not dot\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        voro_margin: 'voro_margin';\r\n        /**\r\n         * Weight of edge.\r\n         * In dot, the heavier the weight, the shorter, straighter and more vertical the edge is. **N.B.** Weights in dot must be integers.\r\n         * For twopi, a weight of 0 indicates the edge should not be used in constructing a spanning tree from the root.\r\n         * For other layouts, a larger weight encourages the layout to make the edge length closer to that specified by the len attribute.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/weight/ Node, Edge and Graph Attributes#weight}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/int/ int}/{@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 1\r\n         * @graphvizMinimum\r\n         * 0(dot,twopi)\r\n         * 1(neato,fdp)\r\n         * @graphvizUsedBy E\r\n         * @category Attribute\r\n         */\r\n        weight: 'weight';\r\n        /**\r\n         * Width of node, in inches.\r\n         * This is taken as the initial, minimum width of the node.\r\n         * If {@link fixedsize} is true, this will be the final width of the node.\r\n         * Otherwise, if the node label requires more width to fit, the node's width will be increased to contain the label.\r\n         * Note also that, if the output format is dot, the value given to width will be the final value.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/width/ Node, Edge and Graph Attributes#width}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 0.75\r\n         * @graphvizMinimum 0.01\r\n         * @graphvizUsedBy N\r\n         * @category Attribute\r\n         */\r\n        width: 'width';\r\n        /**\r\n         * For xdot output, if this attribute is set, this determines the version of xdot used in output.\r\n         * If not set, the attribute will be set to the xdot version used for output.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/xdotversion/ Node, Edge and Graph Attributes#xdotversion}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/string/ string}\r\n         * @graphvizNotes xdot only\r\n         * @graphvizUsedBy G\r\n         * @category Attribute\r\n         */\r\n        xdotversion: 'xdotversion';\r\n        /**\r\n         * External label for a node or edge.\r\n         * For nodes, the label will be placed outside of the node but near it.\r\n         * For edges, the label will be placed near the center of the edge.\r\n         * This can be useful in dot to avoid the occasional problem when the use of edge labels distorts the layout.\r\n         * For other layouts, the xlabel attribute can be viewed as a synonym for the {@link label} attribute.\r\n         *\r\n         * These labels are added after all nodes and edges have been placed.\r\n         * The labels will be placed so that they do not overlap any node or label.\r\n         * This means it may not be possible to place all of them.\r\n         * To force placing all of them, use the {@link forcelabels} attribute.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/xlabel/ Node, Edge and Graph Attributes#xlabel}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/lblString/ lblString}\r\n         * @graphvizDefault \"\"\r\n         * @graphvizUsedBy EN\r\n         * @category Attribute\r\n         */\r\n        xlabel: 'xlabel';\r\n        /**\r\n         * Position of an exterior label, {@link https://graphviz.org/doc/info/attrs.html in points}.\r\n         * The position indicates the center of the label.\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/xlp/ Node, Edge and Graph Attributes#xlp}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/point/ point}\r\n         * @graphvizNotes write only\r\n         * @graphvizUsedBy NE\r\n         * @category Attribute\r\n         */\r\n        xlp: 'xlp';\r\n        /**\r\n         * Deprecated:Use {@link pos} attribute, along with {@link dimen} and/or {@link dim} to specify dimensions.\r\n         *\r\n         * Provides z coordinate value for 3D layouts and displays.\r\n         * If the graph has {@link dim} set to 3 (or more), neato will use a node's **z** value for the z coordinate of its initial position if its {@link pos} attribute is also defined.\r\n         *\r\n         * Even if no **z** values are specified in the input, it is necessary to declare a **z** attribute for nodes, e.g,\r\n         * using node[z=\"\"] in order to get z values on output.\r\n         * Thus, setting dim=3 but not declaring **z** will cause neato -Tvrml to layout the graph in 3D but project the layout onto the xy-plane for the rendering.\r\n         * If the **z** attribute is declared, the final rendering will be in 3D.\r\n         *\r\n         *\r\n         * @see {@link https://graphviz.org/docs/attrs/z/ Node, Edge and Graph Attributes#z}\r\n         * @graphvizType {@link https://graphviz.org/docs/attr-types/double/ double}\r\n         * @graphvizDefault 0\r\n         * @graphvizMinimum\r\n         * -MAXFLOAT\r\n         * -1000\r\n         * @graphvizUsedBy N\r\n         * @deprecated\r\n         * @category Attribute\r\n         */\r\n        z: 'z';\r\n    }\r\n    /**\r\n     * $types is an interface that defines a set of attributes that can be used to configure a graph.\r\n     */\r\n    export interface $types {\r\n        _background: string;\r\n        area: Double;\r\n        arrowhead: ArrowType;\r\n        arrowsize: Double;\r\n        arrowtail: ArrowType;\r\n        bb: Rect;\r\n        bgcolor: Color | ColorList;\r\n        TBbalance: TBbalanceType;\r\n        center: boolean;\r\n        charset: string;\r\n        class: string;\r\n        clusterrank: ClusterMode;\r\n        color: Color | ColorList;\r\n        colorscheme: string;\r\n        comment: string;\r\n        compound: boolean;\r\n        concentrate: boolean;\r\n        constraint: boolean;\r\n        Damping: Double;\r\n        decorate: boolean;\r\n        defaultdist: Double;\r\n        dim: Int;\r\n        dimen: Int;\r\n        dir: DirType;\r\n        diredgeconstraints: string | boolean;\r\n        distortion: Double;\r\n        dpi: Double;\r\n        edgehref: EscString;\r\n        edgetarget: EscString;\r\n        edgetooltip: EscString;\r\n        edgeURL: EscString;\r\n        epsilon: Double;\r\n        esep: AddDouble | AddPoint;\r\n        fillcolor: Color | ColorList;\r\n        fixedsize: boolean | string;\r\n        fontcolor: Color;\r\n        fontname: string;\r\n        fontnames: string;\r\n        fontpath: string;\r\n        fontsize: Double;\r\n        forcelabels: boolean;\r\n        gradientangle: Blank | Int;\r\n        group: string;\r\n        head_lp: Point;\r\n        headclip: boolean;\r\n        headhref: EscString;\r\n        headlabel: LblString;\r\n        headport: PortPos;\r\n        headtarget: EscString;\r\n        headtooltip: EscString;\r\n        headURL: EscString;\r\n        height: Blank | Double;\r\n        href: EscString;\r\n        id: EscString;\r\n        image: string;\r\n        imagepath: string;\r\n        imagepos: string;\r\n        imagescale: string | boolean;\r\n        inputscale: Double;\r\n        K: Double;\r\n        label: LblString;\r\n        label_scheme: Int;\r\n        labelangle: Double;\r\n        labeldistance: Double;\r\n        labelfloat: boolean;\r\n        labelfontcolor: Color;\r\n        labelfontname: string;\r\n        labelfontsize: Double;\r\n        labelhref: EscString;\r\n        labeljust: string;\r\n        labelloc: string;\r\n        labeltarget: EscString;\r\n        labeltooltip: EscString;\r\n        labelURL: EscString;\r\n        landscape: boolean;\r\n        layer: LayerRange;\r\n        layerlistsep: string;\r\n        layers: LayerList;\r\n        layerselect: LayerRange;\r\n        layersep: string;\r\n        layout: string;\r\n        len: Double;\r\n        levels: Int;\r\n        levelsgap: Double;\r\n        lhead: string;\r\n        lheight: Double;\r\n        lp: Point;\r\n        ltail: string;\r\n        lwidth: Double;\r\n        margin: Double | Point;\r\n        maxiter: Int;\r\n        mclimit: Double;\r\n        mindist: Double;\r\n        minlen: Int;\r\n        mode: string;\r\n        model: string;\r\n        mosek: boolean;\r\n        newrank: boolean;\r\n        nodesep: Double;\r\n        nojustify: boolean;\r\n        normalize: Double | boolean;\r\n        notranslate: boolean;\r\n        nslimit: Double;\r\n        nslimit1: Double;\r\n        ordering: string;\r\n        orientation: string | Double;\r\n        outputorder: OutputMode;\r\n        overlap: string | boolean;\r\n        overlap_scaling: Double;\r\n        overlap_shrink: boolean;\r\n        pack: boolean | Int;\r\n        packmode: PackMode;\r\n        pad: Double | Point;\r\n        page: Double | Point;\r\n        pagedir: Pagedir;\r\n        pencolor: Color;\r\n        penwidth: Double;\r\n        peripheries: Int;\r\n        pin: boolean;\r\n        pos: Point | SplineType;\r\n        quadtree: QuadType | boolean;\r\n        quantum: Double;\r\n        rank: RankType;\r\n        rankdir: Rankdir;\r\n        ranksep: Double | DoubleList;\r\n        ratio: Double | string;\r\n        rects: Rect;\r\n        regular: boolean;\r\n        remincross: boolean;\r\n        repulsiveforce: Double;\r\n        resolution: Double;\r\n        root: string | boolean;\r\n        rotate: Int;\r\n        rotation: Double;\r\n        samehead: string;\r\n        sametail: string;\r\n        samplepoints: Int;\r\n        scale: Double | Point;\r\n        searchsize: Int;\r\n        sep: AddDouble | AddPoint;\r\n        shape: Shape;\r\n        shapefile: string;\r\n        showboxes: Int;\r\n        sides: Int;\r\n        size: Double | Point;\r\n        skew: Double;\r\n        smoothing: SmoothType;\r\n        sortv: Int;\r\n        splines: boolean | string;\r\n        start: Blank | StartType;\r\n        style: Blank | Style;\r\n        stylesheet: string;\r\n        tail_lp: string;\r\n        tailclip: Point;\r\n        tailhref: EscString;\r\n        taillabel: LblString;\r\n        tailport: PortPos;\r\n        tailtarget: EscString;\r\n        tailtooltip: EscString;\r\n        tailURL: EscString;\r\n        target: EscString | string;\r\n        tooltip: EscString;\r\n        truecolor: boolean;\r\n        URL: EscString;\r\n        vertices: PointList;\r\n        viewport: Blank | ViewPort;\r\n        voro_margin: Double;\r\n        weight: Int | Double;\r\n        width: Double;\r\n        xdotversion: string;\r\n        xlabel: LblString;\r\n        xlp: Point;\r\n        z: Blank | Double;\r\n    }\r\n}\r\n\r\n/**\r\n * Attribute types.\r\n * @group Attribute\r\n */\r\nexport declare type AttributeKey = NodeAttributeKey | EdgeAttributeKey | GraphAttributeKey | SubgraphAttributeKey | ClusterSubgraphAttributeKey;\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare type AttributeListKind = 'Graph' | 'Edge' | 'Node';\r\n\r\n/**\r\n * A list object of attributes commonly specified for nodes, subgraphs, and edges\r\n * under graph and subgraph.\r\n *\r\n * @typeParam K - The type of object is being specified.\r\n * @typeParam T - The attribute keys to set DOT object.\r\n * @group Models\r\n */\r\nexport declare interface AttributeListModel<K extends AttributeListKind = AttributeListKind, T extends AttributeKey = AttributeKey> extends Attributes<T>, HasComment, DotObjectModel<'AttributeList'> {\r\n    $$kind: K;\r\n}\r\n\r\n/**\r\n * DOT object with the property\r\n * that attributes can be held as a set of keys and values.\r\n *\r\n * @typeParam T - The attribute keys to set DOT object.\r\n * @group Models\r\n */\r\nexport declare interface Attributes<T extends AttributeKey> {\r\n    /** Size of the set of keys and values held by the DOT object. */\r\n    readonly size: number;\r\n    /** The key/value tuples of the object attributes. */\r\n    readonly values: ReadonlyArray<[T, Attribute<T>]>;\r\n    /**\r\n     * Get the value of an attribute by a DOT object by specifying its key.\r\n     *\r\n     * If the value corresponding to the key does not exist, undefined is returned.\r\n     */\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    /** Set a value, by specifying the key of the attributes in the DOT object. */\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    /**\r\n     * Apply keys and values that can be specified for DOT objects collectively.\r\n     *\r\n     * @param attributes - An array of objects or tuples of attribute key/value pairs.\r\n     */\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    /** Delete the value of an attribute from a DOT object by specifying a key. */\r\n    delete(key: T): void;\r\n    /** Delete all attributes specified for the DOT object. */\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * An array of attribute key/value tuple.\r\n * @group Models\r\n */\r\nexport declare type AttributesEntities<T extends AttributeKey> = readonly [\r\nT,\r\nAttribute<T>\r\n][];\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare interface AttributesGroupModel<T extends AttributeKey> extends Attributes<T>, HasComment {\r\n}\r\n\r\n/**\r\n * An objects of attribute key/value pairs.\r\n * @group Models\r\n */\r\nexport declare type AttributesObject<T extends AttributeKey> = {\r\n    [K in T]?: Attribute<K>;\r\n};\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare type AttributeValue = Attribute<AttributeKey>;\r\n\r\n/**\r\n * A value specifying an empty string for resetting some values.\r\n * @group Attribute Types\r\n */\r\nexport declare type Blank = '';\r\n\r\n/**\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/clusterMode/ clusterMode}\r\n * @group Attribute Types\r\n */\r\nexport declare type ClusterMode = ClusterMode.values;\r\n\r\nexport declare namespace ClusterMode {\r\n    export type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\r\n    export interface $values extends $keywords<'local' | 'global' | 'none'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/**\r\n * Attribute types available for cluster subgraph.\r\n * @group Attribute\r\n */\r\nexport declare type ClusterSubgraphAttributeKey = ClusterSubgraphAttributeKey.values;\r\n\r\n/** @hidden */\r\nexport declare namespace ClusterSubgraphAttributeKey {\r\n    export type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\r\n    export interface $values extends $keywords<'K' | 'URL' | 'area' | 'bgcolor' | 'color' | 'colorscheme' | 'fillcolor' | 'fontcolor' | 'fontname' | 'fontsize' | 'gradientangle' | 'href' | 'id' | 'label' | 'labeljust' | 'labelloc' | 'layer' | 'lheight' | 'lp' | 'lwidth' | 'margin' | 'nojustify' | 'pencolor' | 'penwidth' | 'peripheries' | 'sortv' | 'style' | 'target' | 'tooltip' | 'class'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/**\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/color/ color}\r\n * @group Attribute Types\r\n */\r\nexport declare type Color = Color.RGB_RGBA | Color.HSV | Color.ColorName | number;\r\n\r\n/** @hidden */\r\nexport declare namespace Color {\r\n    /**\r\n     * `\"#%2x%2x%2x\"` Red-Green-Blue (RGB)\r\n     *\r\n     * `\"#%2x%2x%2x%2x\"` Red-Green-Blue-Alpha (RGBA)\r\n     * @note A type that is too complicated to express in TypeScript.\r\n     */\r\n    export type RGB_RGBA = `#${string}`;\r\n    /**\r\n     * Hue-Saturation-Value (HSV) 0.0 <= H,S,V <= 1.0\r\n     */\r\n    export type HSV = `${number}+${number}+${number}`;\r\n    /**\r\n     * Color names are resolved in the context of a color scheme.\r\n     *\r\n     * Graphviz currently supports the X11 scheme, the SVG scheme, and the Brewer schemes, with X11 being the default.\r\n     * @see {@link https://graphviz.org/doc/info/colors.html Color Names}\r\n     */\r\n    export type ColorName = Exclude<keyof $colors, keyof $exclude>;\r\n    export interface $colors extends $keywords<'aliceblue' | 'antiquewhite' | 'antiquewhite1' | 'antiquewhite2' | 'antiquewhite3' | 'antiquewhite4' | 'aqua' | 'aquamarine' | 'aquamarine1' | 'aquamarine2' | 'aquamarine3' | 'aquamarine4' | 'azure' | 'azure1' | 'azure2' | 'azure3' | 'azure4' | 'beige' | 'bisque' | 'bisque1' | 'bisque2' | 'bisque3' | 'bisque4' | 'black' | 'blanchedalmond' | 'blue' | 'blue1' | 'blue2' | 'blue3' | 'blue4' | 'blueviolet' | 'brown' | 'brown1' | 'brown2' | 'brown3' | 'brown4' | 'burlywood' | 'burlywood1' | 'burlywood2' | 'burlywood3' | 'burlywood4' | 'cadetblue' | 'cadetblue1' | 'cadetblue2' | 'cadetblue3' | 'cadetblue4' | 'chartreuse' | 'chartreuse1' | 'chartreuse2' | 'chartreuse3' | 'chartreuse4' | 'chocolate' | 'chocolate1' | 'chocolate2' | 'chocolate3' | 'chocolate4' | 'coral' | 'coral1' | 'coral2' | 'coral3' | 'coral4' | 'cornflowerblue' | 'cornsilk' | 'cornsilk1' | 'cornsilk2' | 'cornsilk3' | 'cornsilk4' | 'crimson' | 'cyan' | 'cyan1' | 'cyan2' | 'cyan3' | 'cyan4' | 'darkblue' | 'darkcyan' | 'darkgoldenrod' | 'darkgoldenrod1' | 'darkgoldenrod2' | 'darkgoldenrod3' | 'darkgoldenrod4' | 'darkgray' | 'darkgreen' | 'darkgrey' | 'darkkhaki' | 'darkmagenta' | 'darkolivegreen' | 'darkolivegreen1' | 'darkolivegreen2' | 'darkolivegreen3' | 'darkolivegreen4' | 'darkorange' | 'darkorange1' | 'darkorange2' | 'darkorange3' | 'darkorange4' | 'darkorchid' | 'darkorchid1' | 'darkorchid2' | 'darkorchid3' | 'darkorchid4' | 'darkred' | 'darksalmon' | 'darkseagreen' | 'darkseagreen1' | 'darkseagreen2' | 'darkseagreen3' | 'darkseagreen4' | 'darkslateblue' | 'darkslategray' | 'darkslategray1' | 'darkslategray2' | 'darkslategray3' | 'darkslategray4' | 'darkslategrey' | 'darkturquoise' | 'darkviolet' | 'deeppink' | 'deeppink1' | 'deeppink2' | 'deeppink3' | 'deeppink4' | 'deepskyblue' | 'deepskyblue1' | 'deepskyblue2' | 'deepskyblue3' | 'deepskyblue4' | 'dimgray' | 'dimgrey' | 'dodgerblue' | 'dodgerblue1' | 'dodgerblue2' | 'dodgerblue3' | 'dodgerblue4' | 'firebrick' | 'firebrick1' | 'firebrick2' | 'firebrick3' | 'firebrick4' | 'floralwhite' | 'forestgreen' | 'fuchsia' | 'gainsboro' | 'ghostwhite' | 'gold' | 'gold1' | 'gold2' | 'gold3' | 'gold4' | 'goldenrod' | 'goldenrod1' | 'goldenrod2' | 'goldenrod3' | 'goldenrod4' | 'gray' | 'gray0' | 'gray1' | 'gray10' | 'gray100' | 'gray11' | 'gray12' | 'gray13' | 'gray14' | 'gray15' | 'gray16' | 'gray17' | 'gray18' | 'gray19' | 'gray2' | 'gray20' | 'gray21' | 'gray22' | 'gray23' | 'gray24' | 'gray25' | 'gray26' | 'gray27' | 'gray28' | 'gray29' | 'gray3' | 'gray30' | 'gray31' | 'gray32' | 'gray33' | 'gray34' | 'gray35' | 'gray36' | 'gray37' | 'gray38' | 'gray39' | 'gray4' | 'gray40' | 'gray41' | 'gray42' | 'gray43' | 'gray44' | 'gray45' | 'gray46' | 'gray47' | 'gray48' | 'gray49' | 'gray5' | 'gray50' | 'gray51' | 'gray52' | 'gray53' | 'gray54' | 'gray55' | 'gray56' | 'gray57' | 'gray58' | 'gray59' | 'gray6' | 'gray60' | 'gray61' | 'gray62' | 'gray63' | 'gray64' | 'gray65' | 'gray66' | 'gray67' | 'gray68' | 'gray69' | 'gray7' | 'gray70' | 'gray71' | 'gray72' | 'gray73' | 'gray74' | 'gray75' | 'gray76' | 'gray77' | 'gray78' | 'gray79' | 'gray8' | 'gray80' | 'gray81' | 'gray82' | 'gray83' | 'gray84' | 'gray85' | 'gray86' | 'gray87' | 'gray88' | 'gray89' | 'gray9' | 'gray90' | 'gray91' | 'gray92' | 'gray93' | 'gray94' | 'gray95' | 'gray96' | 'gray97' | 'gray98' | 'gray99' | 'green' | 'green1' | 'green2' | 'green3' | 'green4' | 'greenyellow' | 'grey' | 'grey0' | 'grey1' | 'grey10' | 'grey100' | 'grey11' | 'grey12' | 'grey13' | 'grey14' | 'grey15' | 'grey16' | 'grey17' | 'grey18' | 'grey19' | 'grey2' | 'grey20' | 'grey21' | 'grey22' | 'grey23' | 'grey24' | 'grey25' | 'grey26' | 'grey27' | 'grey28' | 'grey29' | 'grey3' | 'grey30' | 'grey31' | 'grey32' | 'grey33' | 'grey34' | 'grey35' | 'grey36' | 'grey37' | 'grey38' | 'grey39' | 'grey4' | 'grey40' | 'grey41' | 'grey42' | 'grey43' | 'grey44' | 'grey45' | 'grey46' | 'grey47' | 'grey48' | 'grey49' | 'grey5' | 'grey50' | 'grey51' | 'grey52' | 'grey53' | 'grey54' | 'grey55' | 'grey56' | 'grey57' | 'grey58' | 'grey59' | 'grey6' | 'grey60' | 'grey61' | 'grey62' | 'grey63' | 'grey64' | 'grey65' | 'grey66' | 'grey67' | 'grey68' | 'grey69' | 'grey7' | 'grey70' | 'grey71' | 'grey72' | 'grey73' | 'grey74' | 'grey75' | 'grey76' | 'grey77' | 'grey78' | 'grey79' | 'grey8' | 'grey80' | 'grey81' | 'grey82' | 'grey83' | 'grey84' | 'grey85' | 'grey86' | 'grey87' | 'grey88' | 'grey89' | 'grey9' | 'grey90' | 'grey91' | 'grey92' | 'grey93' | 'grey94' | 'grey95' | 'grey96' | 'grey97' | 'grey98' | 'grey99' | 'honeydew' | 'honeydew1' | 'honeydew2' | 'honeydew3' | 'honeydew4' | 'hotpink' | 'hotpink1' | 'hotpink2' | 'hotpink3' | 'hotpink4' | 'indianred' | 'indianred1' | 'indianred2' | 'indianred3' | 'indianred4' | 'indigo' | 'invis' | 'ivory' | 'ivory1' | 'ivory2' | 'ivory3' | 'ivory4' | 'khaki' | 'khaki1' | 'khaki2' | 'khaki3' | 'khaki4' | 'lavender' | 'lavenderblush' | 'lavenderblush1' | 'lavenderblush2' | 'lavenderblush3' | 'lavenderblush4' | 'lawngreen' | 'lemonchiffon' | 'lemonchiffon1' | 'lemonchiffon2' | 'lemonchiffon3' | 'lemonchiffon4' | 'lightblue' | 'lightblue1' | 'lightblue2' | 'lightblue3' | 'lightblue4' | 'lightcoral' | 'lightcyan' | 'lightcyan1' | 'lightcyan2' | 'lightcyan3' | 'lightcyan4' | 'lightgoldenrod' | 'lightgoldenrod1' | 'lightgoldenrod2' | 'lightgoldenrod3' | 'lightgoldenrod4' | 'lightgoldenrodyellow' | 'lightgray' | 'lightgreen' | 'lightgrey' | 'lightpink' | 'lightpink1' | 'lightpink2' | 'lightpink3' | 'lightpink4' | 'lightsalmon' | 'lightsalmon1' | 'lightsalmon2' | 'lightsalmon3' | 'lightsalmon4' | 'lightseagreen' | 'lightskyblue' | 'lightskyblue1' | 'lightskyblue2' | 'lightskyblue3' | 'lightskyblue4' | 'lightslateblue' | 'lightslategray' | 'lightslategrey' | 'lightsteelblue' | 'lightsteelblue1' | 'lightsteelblue2' | 'lightsteelblue3' | 'lightsteelblue4' | 'lightyellow' | 'lightyellow1' | 'lightyellow2' | 'lightyellow3' | 'lightyellow4' | 'lime' | 'limegreen' | 'linen' | 'magenta' | 'magenta1' | 'magenta2' | 'magenta3' | 'magenta4' | 'maroon' | 'maroon1' | 'maroon2' | 'maroon3' | 'maroon4' | 'mediumaquamarine' | 'mediumblue' | 'mediumorchid' | 'mediumorchid1' | 'mediumorchid2' | 'mediumorchid3' | 'mediumorchid4' | 'mediumpurple' | 'mediumpurple1' | 'mediumpurple2' | 'mediumpurple3' | 'mediumpurple4' | 'mediumseagreen' | 'mediumslateblue' | 'mediumspringgreen' | 'mediumturquoise' | 'mediumvioletred' | 'midnightblue' | 'mintcream' | 'mistyrose' | 'mistyrose1' | 'mistyrose2' | 'mistyrose3' | 'mistyrose4' | 'moccasin' | 'navajowhite' | 'navajowhite1' | 'navajowhite2' | 'navajowhite3' | 'navajowhite4' | 'navy' | 'navyblue' | 'none' | 'oldlace' | 'olive' | 'olivedrab' | 'olivedrab1' | 'olivedrab2' | 'olivedrab3' | 'olivedrab4' | 'orange' | 'orange1' | 'orange2' | 'orange3' | 'orange4' | 'orangered' | 'orangered1' | 'orangered2' | 'orangered3' | 'orangered4' | 'orchid' | 'orchid1' | 'orchid2' | 'orchid3' | 'orchid4' | 'palegoldenrod' | 'palegreen' | 'palegreen1' | 'palegreen2' | 'palegreen3' | 'palegreen4' | 'paleturquoise' | 'paleturquoise1' | 'paleturquoise2' | 'paleturquoise3' | 'paleturquoise4' | 'palevioletred' | 'palevioletred1' | 'palevioletred2' | 'palevioletred3' | 'palevioletred4' | 'papayawhip' | 'peachpuff' | 'peachpuff1' | 'peachpuff2' | 'peachpuff3' | 'peachpuff4' | 'peru' | 'pink' | 'pink1' | 'pink2' | 'pink3' | 'pink4' | 'plum' | 'plum1' | 'plum2' | 'plum3' | 'plum4' | 'powderblue' | 'purple' | 'purple1' | 'purple2' | 'purple3' | 'purple4' | 'rebeccapurple' | 'red' | 'red1' | 'red2' | 'red3' | 'red4' | 'rosybrown' | 'rosybrown1' | 'rosybrown2' | 'rosybrown3' | 'rosybrown4' | 'royalblue' | 'royalblue1' | 'royalblue2' | 'royalblue3' | 'royalblue4' | 'saddlebrown' | 'salmon' | 'salmon1' | 'salmon2' | 'salmon3' | 'salmon4' | 'sandybrown' | 'seagreen' | 'seagreen1' | 'seagreen2' | 'seagreen3' | 'seagreen4' | 'seashell' | 'seashell1' | 'seashell2' | 'seashell3' | 'seashell4' | 'sienna' | 'sienna1' | 'sienna2' | 'sienna3' | 'sienna4' | 'silver' | 'skyblue' | 'skyblue1' | 'skyblue2' | 'skyblue3' | 'skyblue4' | 'slateblue' | 'slateblue1' | 'slateblue2' | 'slateblue3' | 'slateblue4' | 'slategray' | 'slategray1' | 'slategray2' | 'slategray3' | 'slategray4' | 'slategrey' | 'snow' | 'snow1' | 'snow2' | 'snow3' | 'snow4' | 'springgreen' | 'springgreen1' | 'springgreen2' | 'springgreen3' | 'springgreen4' | 'steelblue' | 'steelblue1' | 'steelblue2' | 'steelblue3' | 'steelblue4' | 'tan' | 'tan1' | 'tan2' | 'tan3' | 'tan4' | 'teal' | 'thistle' | 'thistle1' | 'thistle2' | 'thistle3' | 'thistle4' | 'tomato' | 'tomato1' | 'tomato2' | 'tomato3' | 'tomato4' | 'transparent' | 'turquoise' | 'turquoise1' | 'turquoise2' | 'turquoise3' | 'turquoise4' | 'violet' | 'violetred' | 'violetred1' | 'violetred2' | 'violetred3' | 'violetred4' | 'webgray' | 'webgreen' | 'webgrey' | 'webmaroon' | 'webpurple' | 'wheat' | 'wheat1' | 'wheat2' | 'wheat3' | 'wheat4' | 'white' | 'whitesmoke' | 'x11gray' | 'x11green' | 'x11grey' | 'x11maroon' | 'x11purple' | 'yellow' | 'yellow1' | 'yellow2' | 'yellow3' | 'yellow4' | 'yellowgreen' | 'aliceblue' | 'antiquewhite' | 'aqua' | 'aquamarine' | 'azure' | 'beige' | 'bisque' | 'black' | 'blanchedalmond' | 'blue' | 'blueviolet' | 'brown' | 'burlywood' | 'cadetblue' | 'chartreuse' | 'chocolate' | 'coral' | 'cornflowerblue' | 'cornsilk' | 'crimson' | 'cyan' | 'darkblue' | 'darkcyan' | 'darkgoldenrod' | 'darkgray' | 'darkgreen' | 'darkgrey' | 'darkkhaki' | 'darkmagenta' | 'darkolivegreen' | 'darkorange' | 'darkorchid' | 'darkred' | 'darksalmon' | 'darkseagreen' | 'darkslateblue' | 'darkslategray' | 'darkslategrey' | 'darkturquoise' | 'darkviolet' | 'deeppink' | 'deepskyblue' | 'dimgray' | 'dimgrey' | 'dodgerblue' | 'firebrick' | 'floralwhite' | 'forestgreen' | 'fuchsia' | 'gainsboro' | 'ghostwhite' | 'gold' | 'goldenrod' | 'gray' | 'grey' | 'green' | 'greenyellow' | 'honeydew' | 'hotpink' | 'indianred' | 'indigo' | 'ivory' | 'khaki' | 'lavender' | 'lavenderblush' | 'lawngreen' | 'lemonchiffon' | 'lightblue' | 'lightcoral' | 'lightcyan' | 'lightgoldenrodyellow' | 'lightgray' | 'lightgreen' | 'lightgrey' | 'lightpink' | 'lightsalmon' | 'lightseagreen' | 'lightskyblue' | 'lightslategray' | 'lightslategrey' | 'lightsteelblue' | 'lightyellow' | 'lime' | 'limegreen' | 'linen' | 'magenta' | 'maroon' | 'mediumaquamarine' | 'mediumblue' | 'mediumorchid' | 'mediumpurple' | 'mediumseagreen' | 'mediumslateblue' | 'mediumspringgreen' | 'mediumturquoise' | 'mediumvioletred' | 'midnightblue' | 'mintcream' | 'mistyrose' | 'moccasin' | 'navajowhite' | 'navy' | 'oldlace' | 'olive' | 'olivedrab' | 'orange' | 'orangered' | 'orchid' | 'palegoldenrod' | 'palegreen' | 'paleturquoise' | 'palevioletred' | 'papayawhip' | 'peachpuff' | 'peru' | 'pink' | 'plum' | 'powderblue' | 'purple' | 'red' | 'rosybrown' | 'royalblue' | 'saddlebrown' | 'salmon' | 'sandybrown' | 'seagreen' | 'seashell' | 'sienna' | 'silver' | 'skyblue' | 'slateblue' | 'slategray' | 'slategrey' | 'snow' | 'springgreen' | 'steelblue' | 'tan' | 'teal' | 'thistle' | 'tomato' | 'turquoise' | 'violet' | 'wheat' | 'white' | 'whitesmoke' | 'yellow' | 'yellowgreen'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/**\r\n * A colon-separated list of weighted color values: WC(:WC)* where each WC has the form C(;F)? with C a color value and the optional F a floating-point number, 0  F  1.\r\n *\r\n * The sum of the floating-point numbers in a colorList must sum to at most 1.\r\n *\r\n * @note A type that is too complicated to express in TypeScript.\r\n *\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/colorList/}\r\n * @group Attribute Types\r\n */\r\nexport declare type ColorList = string;\r\n\r\n/**\r\n * Directive indicating which direction the Edge should point.\r\n * @group Attribute Types\r\n */\r\nexport declare type Compass = Compass.values;\r\n\r\n/** @hidden */\r\nexport declare namespace Compass {\r\n    export type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\r\n    export interface $values extends $keywords<'n' | 'ne' | 'e' | 'se' | 's' | 'sw' | 'w' | 'nw' | 'c' | '_'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/**\r\n * @group Models Context\r\n */\r\nexport declare function createModelsContext(models: Partial<ModelsContext>): ModelsContext;\r\n\r\n/**\r\n * Direction Type\r\n *\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/dirType/ dirType}\r\n * @group Attribute Types\r\n */\r\nexport declare type DirType = DirType.values;\r\n\r\n/** @hidden */\r\nexport declare namespace DirType {\r\n    export type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\r\n    export interface $values extends $keywords<'forward' | 'back' | 'both' | 'none'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/**\r\n * DotObjectModel is an interface that defines a generic type for a {@link DotObjectType}.\r\n *\r\n * @template T The type of the {@link DotObjectType}.\r\n * @group Models\r\n */\r\nexport declare interface DotObjectModel<T extends DotObjectType = DotObjectType> {\r\n    /**\r\n     * The type of the DotObjectType.\r\n     */\r\n    $$type: T;\r\n}\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare type DotObjectType = 'AttributeList' | 'Node' | 'Edge' | 'Subgraph' | 'Graph';\r\n\r\n/**\r\n * Double-precision floating point number.\r\n *\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/double/ double}\r\n * @group Attribute Types\r\n */\r\nexport declare type Double = number;\r\n\r\n/**\r\n * A colon-separated list of doubles: `\"%f(:%f)*\"` where each %f is a double.\r\n *\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/doubleList/ doubleList}\r\n * @group Attribute Types\r\n */\r\nexport declare type DoubleList = Double | `${Double}:${Double}` | `${Double}:${Double}:${Double}` | `${Double}:${Double}:${Double}:${Double}` | `${Double}:${Double}:${Double}:${Double}:${Double}` | `${Double}:${Double}:${Double}:${Double}:${Double}:${Double}` | `${Double}:${Double}:${Double}:${Double}:${Double}:${Double}:${Double}` | `${Double}:${Double}:${Double}:${Double}:${Double}:${Double}:${Double}:${Double}` | `${Double}:${Double}:${Double}:${Double}:${Double}:${Double}:${Double}:${Double}:${Double}`;\r\n\r\n/**\r\n * Attribute types available for edges.\r\n * @group Attribute\r\n */\r\nexport declare type EdgeAttributeKey = EdgeAttributeKey.values;\r\n\r\n/** @hidden */\r\nexport declare namespace EdgeAttributeKey {\r\n    export type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\r\n    export interface $values extends $keywords<'URL' | 'arrowhead' | 'arrowsize' | 'arrowtail' | 'color' | 'colorscheme' | 'comment' | 'constraint' | 'decorate' | 'dir' | 'edgeURL' | 'edgehref' | 'edgetarget' | 'edgetooltip' | 'fillcolor' | 'fontcolor' | 'fontname' | 'fontsize' | 'headURL' | 'head_lp' | 'headclip' | 'headhref' | 'headlabel' | 'headport' | 'headtarget' | 'headtooltip' | 'href' | 'id' | 'label' | 'labelURL' | 'labelangle' | 'labeldistance' | 'labelfloat' | 'labelfontcolor' | 'labelfontname' | 'labelfontsize' | 'labelhref' | 'labeltarget' | 'labeltooltip' | 'layer' | 'len' | 'lhead' | 'lp' | 'ltail' | 'minlen' | 'nojustify' | 'penwidth' | 'pos' | 'samehead' | 'sametail' | 'showboxes' | 'style' | 'tailURL' | 'tail_lp' | 'tailclip' | 'tailhref' | 'taillabel' | 'tailport' | 'tailtarget' | 'tailtooltip' | 'target' | 'tooltip' | 'weight' | 'xlabel' | 'xlp' | 'class'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/**\r\n * Attribute object that can be set to Edge.\r\n * @group Models\r\n */\r\nexport declare type EdgeAttributesObject = AttributesObject<EdgeAttributeKey>;\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare interface EdgeConstructor {\r\n    new (targets: EdgeTargetTuple, attributes?: EdgeAttributesObject): EdgeModel;\r\n    new (...args: any[]): EdgeModel;\r\n}\r\n\r\n/**\r\n * Model that can be converted to Edge in DOT language.\r\n * @group Models\r\n */\r\nexport declare interface EdgeModel extends HasComment, HasAttributes<EdgeAttributeKey>, DotObjectModel<'Edge'> {\r\n    readonly targets: EdgeTargetTuple;\r\n}\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare type EdgeTarget = NodeRef | NodeRefGroup;\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare type EdgeTargetLike = NodeRefLike | NodeRefGroupLike;\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare type EdgeTargetLikeTuple = [\r\nfrom: EdgeTargetLike,\r\nto: EdgeTargetLike,\r\n...rest: EdgeTargetLike[]\r\n];\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare type EdgeTargetTuple = [\r\nfrom: EdgeTarget,\r\nto: EdgeTarget,\r\n...rest: EdgeTarget[]\r\n];\r\n\r\n/**\r\n * String with Escape Sequences\r\n *\r\n * A string allowing escape sequences which are replaced according to the context.\r\n *\r\n * For node attributes, the substring `\"\\N\"` is replaced by the name of the node,\r\n * and the substring `\"\\G\"` by the name of the graph.\r\n *\r\n * For graph or cluster attributes, the substring `\"\\G\"` is replaced by the name of the graph or cluster.\r\n *\r\n * For edge attributes, the substring `\"\\E\"` is replaced by the name of the edge, the substring `\"\\G\"` is replaced by the name of the graph or cluster,\r\n * and the substrings `\"\\T\"` and `\"\\H\"` by the names of the tail and head nodes,\r\n * respectively.\r\n *\r\n * The name of an edge is the string formed from the name of the tail node,\r\n * the appropriate edge operator (`\"--\"` or `\"->\"`) and the name of the head node.\r\n *\r\n * In all cases, the substring `\"\\L\"` is replaced by the object's label attribute.\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/escString/ escString}\r\n * @group Attribute Types\r\n */\r\nexport declare type EscString = string;\r\n\r\nexport declare type F<A extends any[], O> = (...args: A) => O;\r\n\r\nexport declare const filter: <T>(pred: (item: T) => boolean) => (src: Iterable<T>) => T[];\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare interface ForwardRefNode extends Partial<Port> {\r\n    readonly id: string;\r\n}\r\n\r\n/**\r\n * Attribute types available for graph.\r\n * @group Attribute\r\n */\r\nexport declare type GraphAttributeKey = GraphAttributeKey.values;\r\n\r\n/** @hidden */\r\nexport declare namespace GraphAttributeKey {\r\n    export type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\r\n    export interface $values extends $keywords<'Damping' | 'K' | 'URL' | '_background' | 'bb' | 'bgcolor' | 'center' | 'charset' | 'clusterrank' | 'colorscheme' | 'comment' | 'compound' | 'concentrate' | 'defaultdist' | 'dim' | 'dimen' | 'diredgeconstraints' | 'dpi' | 'epsilon' | 'esep' | 'fontcolor' | 'fontname' | 'fontnames' | 'fontpath' | 'fontsize' | 'forcelabels' | 'gradientangle' | 'href' | 'id' | 'imagepath' | 'inputscale' | 'label' | 'label_scheme' | 'labeljust' | 'labelloc' | 'landscape' | 'layerlistsep' | 'layers' | 'layerselect' | 'layersep' | 'layout' | 'levels' | 'levelsgap' | 'lheight' | 'lp' | 'lwidth' | 'margin' | 'maxiter' | 'mclimit' | 'mindist' | 'mode' | 'model' | 'mosek' | 'newrank' | 'nodesep' | 'nojustify' | 'normalize' | 'notranslate' | 'nslimit' | 'nslimit1' | 'ordering' | 'orientation' | 'outputorder' | 'overlap' | 'overlap_scaling' | 'overlap_shrink' | 'pack' | 'packmode' | 'pad' | 'page' | 'pagedir' | 'quadtree' | 'quantum' | 'rankdir' | 'ranksep' | 'ratio' | 'remincross' | 'repulsiveforce' | 'resolution' | 'root' | 'rotate' | 'rotation' | 'scale' | 'searchsize' | 'sep' | 'showboxes' | 'size' | 'smoothing' | 'sortv' | 'splines' | 'start' | 'style' | 'stylesheet' | 'target' | 'truecolor' | 'viewport' | 'voro_margin' | 'xdotversion' | 'class' | 'TBbalance'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/**\r\n * Attribute object that can be set to Graph.\r\n * @group Models\r\n */\r\nexport declare type GraphAttributesObject = AttributesObject<GraphAttributeKey>;\r\n\r\n/**\r\n * DOT model representing a graph/digraph/subgraph.\r\n * @group Models\r\n */\r\nexport declare interface GraphBaseModel<T extends AttributeKey = AttributeKey> extends HasComment, Attributes<T> {\r\n    readonly id?: string;\r\n    readonly attributes: Readonly<GraphCommonAttributes>;\r\n    /** Node objects in the graph. */\r\n    readonly nodes: ReadonlyArray<NodeModel>;\r\n    /** Edge objects in the graph. */\r\n    readonly edges: ReadonlyArray<EdgeModel>;\r\n    /** Subgraph objects in the graph. */\r\n    readonly subgraphs: ReadonlyArray<SubgraphModel>;\r\n    with(models: Partial<ModelsContext>): void;\r\n    /**\r\n     * Add a Node to the graph.\r\n     */\r\n    addNode(node: NodeModel): void;\r\n    /**\r\n     * Add Edge to the graph.\r\n     */\r\n    addEdge(edge: EdgeModel): void;\r\n    /**\r\n     * Add a Subgraph to the graph.\r\n     */\r\n    addSubgraph(subgraph: SubgraphModel): void;\r\n    /**\r\n     * Check if the Node exists in the graph.\r\n     */\r\n    existNode(nodeId: string): boolean;\r\n    /**\r\n     * Check if the Edge exists in the graph.\r\n     */\r\n    existEdge(edge: EdgeModel): boolean;\r\n    /**\r\n     * Check if the Subgraph exists in the graph.\r\n     */\r\n    existSubgraph(subgraph: SubgraphModel): boolean;\r\n    /**\r\n     * Remove Node from the graph.\r\n     */\r\n    removeNode(node: NodeModel | string): void;\r\n    /**\r\n     * Remove Edge from the graph.\r\n     */\r\n    removeEdge(edge: EdgeModel): void;\r\n    /**\r\n     * Remove Subgraph from the graph.\r\n     */\r\n    removeSubgraph(subgraph: SubgraphModel): void;\r\n    /**\r\n     * Create a Node in the graph.\r\n     */\r\n    createNode(id: string, attributes?: NodeAttributesObject): NodeModel;\r\n    /**\r\n     * Create a Subgraph and add it to the graph.\r\n     *\r\n     * @param id - Subgraph ID\r\n     * @param attributes - Subgraph attribute object\r\n     */\r\n    createSubgraph(id?: string, attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    createSubgraph(attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    /**\r\n     * Get Subgraph in cluster by specifying id.\r\n     *\r\n     * If there is no Subgraph with the specified id in the graph, return undefined.\r\n     */\r\n    getSubgraph(id: string): SubgraphModel | undefined;\r\n    /**\r\n     * Get Node in cluster by specifying id.\r\n     *\r\n     * @description\r\n     * If there is no Node with the specified id in the graph, return undefined.\r\n     */\r\n    getNode(id: string): NodeModel | undefined;\r\n    /** Create Edge and add it to the graph. */\r\n    createEdge(targets: EdgeTargetLikeTuple, attributes?: EdgeAttributesObject): EdgeModel;\r\n    /**\r\n     * Create a subgraph by specifying its id (or get it if it already exists).\r\n     *\r\n     * By specifying a callback function, the target subgraph can be received and manipulated as an argument.\r\n     *\r\n     * ```ts\r\n     * const G = digraph('G', (g) => {\r\n     *   // Create a cluster with id as A.\r\n     *   g.subgraph('A', (A) => {\r\n     *     // Create a node with id as A1 in cluster A.\r\n     *     A.node('A1');\r\n     *   });\r\n     * });\r\n     *\r\n     * console.log(toDot(G));\r\n     * // digraph \"G\" {\r\n     * //   subgraph \"A\" {\r\n     * //     \"A1\";\r\n     * //   }\r\n     * // }\r\n     * ```\r\n     *\r\n     * @param id Subgraph ID.\r\n     * @param callback Callbacks for manipulating created or retrieved subgraph.\r\n     */\r\n    subgraph(id: string, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    /**\r\n     * Create a subgraph (or get one if it already exists) and adapt the attributes.\r\n     *\r\n     * By specifying a callback function, the target subgraph can be received and manipulated as an argument.\r\n     *\r\n     * ```ts\r\n     * const G = digraph('G', (g) => {\r\n     *   // Create a cluster with id as A and specifying its attributes.\r\n     *   g.subgraph('A', { [attribute.color]: 'red', [attribute.label]: 'my label' }, (A) => {\r\n     *     // Create a node with id as A1 in cluster A.\r\n     *     A.node('A1');\r\n     *   });\r\n     * });\r\n     *\r\n     * console.log(toDot(G));\r\n     * // digraph \"G\" {\r\n     * //   subgraph \"A\" {\r\n     * //     color = \"red\";\r\n     * //     label = \"my label\";\r\n     * //     \"A1\";\r\n     * //   }\r\n     * // }\r\n     * ```\r\n     *\r\n     * @param id  Subgraph ID.\r\n     * @param attributes Object of attributes to be adapted to the subgraph.\r\n     * @param callback Callbacks for manipulating created or retrieved subgraph.\r\n     */\r\n    subgraph(id: string, attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    /**\r\n     * Create anonymous subgraphs and and adapt the attributes.\r\n     *\r\n     * By specifying a callback function, the target subgraph can be received and manipulated as an argument.\r\n     *\r\n     * ```ts\r\n     * const G = digraph('G', (g) => {\r\n     *   // Create a anonymous cluster and specifying its attributes.\r\n     *   g.subgraph({ [attribute.color]: 'red', [attribute.label]: 'my label' }, (A) => {\r\n     *     // Create a node with id as A1 in anonymous cluster.\r\n     *     A.node('A1');\r\n     *   });\r\n     * });\r\n     *\r\n     * console.log(toDot(G));\r\n     * // digraph \"G\" {\r\n     * //   subgraph {\r\n     * //     color = \"red\";\r\n     * //     label = \"my label\";\r\n     * //     \"A1\";\r\n     * //   }\r\n     * // }\r\n     * ```\r\n     *\r\n     * @param attributes Object of attributes to be adapted to the subgraph.\r\n     * @param callback Callbacks for manipulating created or retrieved subgraph.\r\n     */\r\n    subgraph(attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    /**\r\n     * Create anonymous subgraphs and manipulate them with callback functions.\r\n     *\r\n     * By specifying a callback function, the target subgraph can be received and manipulated as an argument.\r\n     *\r\n     * @param callback Callbacks for manipulating created or retrieved subgraph.\r\n     */\r\n    subgraph(callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    /**\r\n     * Create a node by specifying its id (or get it if it already exists).\r\n     *\r\n     * By specifying a callback function, the target node can be received and manipulated as an argument.\r\n     *\r\n     * ```ts\r\n     * const G = digraph('G', (g) => {\r\n     *   // Create a node with id as A.\r\n     *   g.node('A');\r\n     * });\r\n     *\r\n     * console.log(toDot(G));\r\n     * // digraph \"G\" {\r\n     * //   \"A\";\r\n     * // }\r\n     * ```\r\n     *\r\n     * @param id Node ID.\r\n     * @param callback Callbacks for manipulating created or retrieved node.\r\n     */\r\n    node(id: string, callback?: (node: NodeModel) => void): NodeModel;\r\n    /**\r\n     * Create a node (or get one if it already exists) and adapt the attributes.\r\n     *\r\n     * By specifying a callback function, the target node can be received and manipulated as an argument.\r\n     *\r\n     * ```ts\r\n     * const G = digraph('G', (g) => {\r\n     *   // Create a node by specifying its id and specifying its attributes.\r\n     *   g.node('A', {\r\n     *     [attribute.color]: 'red',\r\n     *     [attribute.label]: 'my label',\r\n     *   });\r\n     * });\r\n     *\r\n     * console.log(toDot(G));\r\n     * // digraph \"G\" {\r\n     * //   \"A\" [\r\n     * //     color = \"red\",\r\n     * //     label = \"my label\",\r\n     * //   ];\r\n     * // }\r\n     * ```\r\n     *\r\n     * @param id Node ID.\r\n     * @param attributes Object of attributes to be adapted to the node.\r\n     * @param callback Callbacks for manipulating created or retrieved node.\r\n     */\r\n    node(id: string, attributes: NodeAttributesObject, callback?: (node: NodeModel) => void): NodeModel;\r\n    /**\r\n     * Set a common attribute for the nodes in the graph.\r\n     *\r\n     * ```ts\r\n     * const G = digraph('G', (g) => {\r\n     *   // Set a common attribute for the nodes in the graph.\r\n     *   g.node({\r\n     *     [attribute.color]: 'red',\r\n     *     [attribute.label]: 'my label',\r\n     *   });\r\n     * });\r\n     *\r\n     * console.log(toDot(G));\r\n     * // digraph \"G\" {\r\n     * //   node [\r\n     * //     color = \"red\",\r\n     * //     label = \"my label\",\r\n     * //   ];\r\n     * // }\r\n     * ```\r\n     *\r\n     * @param attributes Object of attributes to be adapted to the nodes.\r\n     */\r\n    node(attributes: NodeAttributesObject): void;\r\n    /**\r\n     * Create a edge.\r\n     *\r\n     * By specifying a callback function, the target edge can be received and manipulated as an argument.\r\n     *\r\n     * ```ts\r\n     * const G = digraph('G', (g) => {\r\n     *   // Create a edge.\r\n     *   g.edge(['a', 'b']);\r\n     * });\r\n     *\r\n     * console.log(toDot(G));\r\n     * // digraph \"G\" {\r\n     * //   \"a\" -> \"b\";\r\n     * // }\r\n     * ```\r\n     * @param targets Nodes.\r\n     * @param callback Callbacks for manipulating created or retrieved edge.\r\n     */\r\n    edge(targets: EdgeTargetLikeTuple, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    /**\r\n     * Create a edge and adapt the attributes.\r\n     *\r\n     * By specifying a callback function, the target edge can be received and manipulated as an argument.\r\n     *\r\n     * ```ts\r\n     * const G = digraph('G', (g) => {\r\n     *   // Create a edge and specifying its attributes.\r\n     *   g.edge(['a', 'b'], {\r\n     *     [attribute.color]: 'red',\r\n     *     [attribute.label]: 'my label',\r\n     *   });\r\n     * });\r\n     *\r\n     * console.log(toDot(G));\r\n     * // digraph \"G\" {\r\n     * //   \"a\" -> \"b\" [\r\n     * //     color = \"red\",\r\n     * //     label = \"my label\",\r\n     * //   ];\r\n     * // }\r\n     * ```\r\n     *\r\n     * @param attributes Object of attributes to be adapted to the edge.\r\n     * @param callback Callbacks for manipulating created or retrieved edge.\r\n     */\r\n    edge(targets: EdgeTargetLikeTuple, attributes: EdgeAttributesObject, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    /**\r\n     * Set a common attribute for the edges in the graph.\r\n     *\r\n     *\r\n     * ```ts\r\n     * const G = digraph('G', (g) => {\r\n     *   // Set a common attribute for the edges in the graph.\r\n     *   g.edge({\r\n     *     [attribute.color]: 'red',\r\n     *     [attribute.label]: 'my label',\r\n     *   });\r\n     * });\r\n     *\r\n     * console.log(toDot(G));\r\n     * // digraph \"G\" {\r\n     * //   edge [\r\n     * //     color = \"red\",\r\n     * //     label = \"my label\",\r\n     * //   ];\r\n     * // }\r\n     * ```\r\n     * @param attributes Object of attributes to be adapted to the edges.\r\n     */\r\n    edge(attributes: EdgeAttributesObject): void;\r\n    /**\r\n     * Set a common attribute for the graph in the graph.\r\n     *\r\n     * ```ts\r\n     * const G = digraph('G', (g) => {\r\n     *   g.graph({\r\n     *     [attribute.color]: 'red',\r\n     *     [attribute.label]: 'my label',\r\n     *   });\r\n     * });\r\n     *\r\n     * console.log(toDot(G));\r\n     * // digraph \"G\" {\r\n     * //   graph [\r\n     * //     color = \"red\",\r\n     * //     label = \"my label\",\r\n     * //   ];\r\n     * // }\r\n     * ```\r\n     * @param attributes Object of attributes to be adapted to the graph.\r\n     */\r\n    graph(attributes: SubgraphAttributesObject): void;\r\n}\r\n\r\n/**\r\n * Cluster common attribute interface.\r\n * @group Models\r\n */\r\nexport declare interface GraphCommonAttributes {\r\n    /** Manage common attributes of graphs in a graph. */\r\n    graph: AttributeListModel<'Graph', SubgraphAttributeKey | ClusterSubgraphAttributeKey>;\r\n    /** Manage common attributes of edges in a graph. */\r\n    edge: AttributeListModel<'Edge', EdgeAttributeKey>;\r\n    /** Manage common attributes of nodes in a graph. */\r\n    node: AttributeListModel<'Node', NodeAttributeKey>;\r\n}\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare interface HasAttributes<T extends AttributeKey> {\r\n    readonly attributes: AttributesGroupModel<T>;\r\n}\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare interface HasComment {\r\n    /** Comments to include when outputting with toDot. */\r\n    comment?: string;\r\n}\r\n\r\n/**\r\n * @see {@link https://graphviz.org/doc/info/shapes.html#html HTML-Like Labels}\r\n * @group Attribute Types\r\n */\r\nexport declare type HTMLLikeLabel = `<${string}>`;\r\n\r\n/** @hidden */\r\nexport declare namespace HTMLLikeLabel {\r\n    export type TableAttributes = Insensitive<{\r\n        align?: 'CENTER' | 'LEFT' | 'RIGHT';\r\n        bgcolor?: Color | ColorList;\r\n        border?: number;\r\n        cellborder?: number;\r\n        cellPadding?: number;\r\n        cellSpacing?: number;\r\n        color?: Color | ColorList;\r\n        columns?: number;\r\n        fixedSize?: true;\r\n        gradientAngle?: number;\r\n        height?: number;\r\n        href?: string;\r\n        id?: string;\r\n        port?: Compass | string;\r\n        rows?: number;\r\n        sides?: Side.Combinations;\r\n        style?: Style;\r\n        target?: string;\r\n        title?: string;\r\n        tooltip?: string;\r\n        valign?: 'MIDDLE' | 'BOTTOM' | 'TOP';\r\n        width?: number;\r\n    }>;\r\n    export type NoAttributes = Record<string, unknown>;\r\n    export type TrAttributes = NoAttributes;\r\n    export type TdAttributes = Insensitive<{\r\n        align?: 'CENTER' | 'LEFT' | 'RIGHT' | 'TEXT';\r\n        balign?: 'CENTER' | 'LEFT' | 'RIGHT';\r\n        bgcolor?: Color | ColorList;\r\n        border?: number;\r\n        cellPadding?: number;\r\n        cellSpacing?: number;\r\n        color?: Color | ColorList;\r\n        colspan?: number;\r\n        fixedSize?: boolean;\r\n        gradientAngle?: number;\r\n        height?: number;\r\n        href?: string;\r\n        id?: string;\r\n        port?: Compass | string;\r\n        rowSpan?: number;\r\n        sides?: Side.Combinations;\r\n        style?: Style;\r\n        target?: string;\r\n        title?: string;\r\n        tooltip?: string;\r\n        valign?: 'MIDDLE' | 'BOTTOM' | 'TOP';\r\n        width?: number;\r\n    }>;\r\n    export type FontAttributes = Insensitive<{\r\n        color?: Color | ColorList;\r\n        face?: string;\r\n        'point-size'?: number;\r\n    }>;\r\n    export type BrAttributes = Insensitive<{\r\n        align?: 'CENTER' | 'LEFT' | 'RIGHT';\r\n    }>;\r\n    export type ImgAttributes = Insensitive<{\r\n        scale?: boolean | 'WIDTH' | 'HEIGHT' | 'BOTH';\r\n        src?: string;\r\n    }>;\r\n    export type IAttributes = NoAttributes;\r\n    export type BAttributes = NoAttributes;\r\n    export type UAttributes = NoAttributes;\r\n    export type OAttributes = NoAttributes;\r\n    export type SubAttributes = NoAttributes;\r\n    export type SupAttributes = NoAttributes;\r\n    export type SAttributes = NoAttributes;\r\n    export type HrAttributes = NoAttributes;\r\n    export type VrAttributes = NoAttributes;\r\n}\r\n\r\nexport declare type Insensitive<T> = T & Insensitive.LowercaseKeys<T> & Insensitive.UppercaseKeys<T>;\r\n\r\nexport declare namespace Insensitive {\r\n    export type LowercaseKeys<T> = {\r\n        [key in keyof T as Lowercase<string & key>]: T[key];\r\n    };\r\n    export type UppercaseKeys<T> = {\r\n        [key in keyof T as Uppercase<string & key>]: T[key];\r\n    };\r\n}\r\n\r\n/**\r\n * Integer number.\r\n *\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/int/ int}\r\n * @group Attribute Types\r\n */\r\nexport declare type Int = number;\r\n\r\nexport declare type IO<I, O> = F<[I], O>;\r\n\r\n/** @hidden */\r\nexport declare function isCompass(c: string): c is Compass;\r\n\r\n/** @hidden */\r\nexport declare function isForwardRefNode(object: unknown): object is ForwardRefNode;\r\n\r\n/** @hidden */\r\nexport declare function isNodeModel(object: unknown): object is NodeModel;\r\n\r\n/** @hidden */\r\nexport declare function isNodeRef(node: unknown): node is NodeRef;\r\n\r\n/** @hidden */\r\nexport declare function isNodeRefGroupLike(target: NodeRefLike | NodeRefGroupLike): target is NodeRefGroupLike;\r\n\r\n/** @hidden */\r\nexport declare function isNodeRefLike(node: unknown): node is NodeRefLike;\r\n\r\n/**\r\n * list of strings separated by characters from the layersep attribute (by default, colons, tabs or spaces),\r\n * defining layer names and implicitly numbered 1,2,\r\n *\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/layerList/ layerList}\r\n * @group Attribute Types\r\n */\r\nexport declare type LayerList = string;\r\n\r\n/**\r\n * specifies a list of layers defined by the layers attribute.\r\n *\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/layerRange/ layerRange}\r\n * @group Attribute Types\r\n */\r\nexport declare type LayerRange = string;\r\n\r\n/**\r\n * An escString or an HTML label.\r\n *\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/lblString/ lblString}\r\n * @group Attribute Types\r\n */\r\nexport declare type LblString = HTMLLikeLabel | EscString;\r\n\r\nexport declare const map: <T, O>(selector: (item: T) => O) => (src: Iterable<T>) => O[];\r\n\r\n/**\r\n * @group Models Context\r\n */\r\nexport declare interface ModelsContext {\r\n    Graph: RootGraphConstructor;\r\n    Digraph: RootGraphConstructor;\r\n    Subgraph: SubgraphConstructor;\r\n    Node: NodeConstructor;\r\n    Edge: EdgeConstructor;\r\n}\r\n\r\n/**\r\n * Attribute types available for nodes.\r\n * @group Attribute\r\n */\r\nexport declare type NodeAttributeKey = NodeAttributeKey.values;\r\n\r\n/** @hidden */\r\nexport declare namespace NodeAttributeKey {\r\n    export type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\r\n    export interface $values extends $keywords<'URL' | 'area' | 'color' | 'colorscheme' | 'comment' | 'distortion' | 'fillcolor' | 'fixedsize' | 'fontcolor' | 'fontname' | 'fontsize' | 'gradientangle' | 'group' | 'height' | 'href' | 'id' | 'image' | 'imagepos' | 'imagescale' | 'label' | 'labelloc' | 'layer' | 'margin' | 'nojustify' | 'ordering' | 'orientation' | 'penwidth' | 'peripheries' | 'pin' | 'pos' | 'rects' | 'regular' | 'root' | 'samplepoints' | 'shape' | 'shapefile' | 'showboxes' | 'sides' | 'skew' | 'sortv' | 'style' | 'target' | 'tooltip' | 'vertices' | 'width' | 'xlabel' | 'xlp' | 'z' | 'class'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/**\r\n * Attribute object that can be set to Node.\r\n * @group Models\r\n */\r\nexport declare type NodeAttributesObject = AttributesObject<NodeAttributeKey>;\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare interface NodeConstructor {\r\n    new (id: string, attributes?: NodeAttributesObject): NodeModel;\r\n    new (...args: any[]): NodeModel;\r\n}\r\n\r\n/**\r\n * Model that can be converted to Node in DOT language.\r\n * @group Models\r\n */\r\nexport declare interface NodeModel extends HasComment, HasAttributes<NodeAttributeKey>, DotObjectModel<'Node'> {\r\n    /** ID of the node */\r\n    readonly id: string;\r\n    /** Returns ForwardRefNode with port and compass specified. */\r\n    port(port: string | Partial<Port>): ForwardRefNode;\r\n}\r\n\r\n/**\r\n * Objects that can be Edge destinations satisfy this interface.\r\n * @group Models\r\n */\r\nexport declare type NodeRef = NodeModel | ForwardRefNode;\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare type NodeRefGroup = NodeRef[];\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare type NodeRefGroupLike = NodeRefLike[];\r\n\r\n/**\r\n * string or an object implementing EdgeTarget.\r\n * @group Models\r\n */\r\nexport declare type NodeRefLike = NodeRef | string;\r\n\r\n/**\r\n * These specify the order in which nodes and edges are drawn in concrete output.\r\n *\r\n * - The default `\"breadthfirst\"` is the simplest, but when the graph layout does not avoid edge-node overlap, this mode will sometimes have edges drawn over nodes and sometimes on top of nodes.\r\n * - If the mode `\"nodesfirst\"` is chosen, all nodes are drawn first, followed by the edges. This guarantees an edge-node overlap will not be mistaken for an edge ending at a node.\r\n * - On the other hand, usually for aesthetic reasons, it may be desirable that all edges appear beneath nodes, even if the resulting drawing is ambiguous. This can be achieved by choosing `\"edgesfirst\"`.\r\n *\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/outputMode/ outputMode}\r\n * @group Attribute Types\r\n */\r\nexport declare type OutputMode = OutputMode.values;\r\n\r\n/** @hidden */\r\nexport declare namespace OutputMode {\r\n    export type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\r\n    export interface $values extends $keywords<'breadthfirst' | 'nodesfirst' | 'edgesfirst'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/**\r\n * @see {@link https://graphviz.org/docs/attr-types/packMode/ packMode}\r\n * @group Attribute Types\r\n */\r\nexport declare type PackMode = keyof PickMode.$values | `array${string}`;\r\n\r\n/**\r\n * Page Direction\r\n *\r\n * @see {@link https://graphviz.org/docs/attr-types/pagedir/ pagedir}\r\n * @group Attribute Types\r\n */\r\nexport declare type Pagedir = `${Pagedir.TB}${Pagedir.RL}`;\r\n\r\n/** @hidden */\r\nexport declare namespace Pagedir {\r\n    export type TB = Side.T | Side.B;\r\n    export type RL = Side.R | Side.L;\r\n}\r\n\r\n/** @hidden */\r\nexport declare namespace PickMode {\r\n    export type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\r\n    export interface $values extends $keywords<'node' | 'clust' | 'graph'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\nexport declare function pipe<I extends any[], O>(f0: F<I, O>): F<I, O>;\r\n\r\nexport declare function pipe<I extends any[], T1, O>(f0: F<I, T1>, f1: IO<T1, O>): F<I, O>;\r\n\r\nexport declare function pipe<I extends any[], T1, T2, O>(f0: F<I, T1>, f1: IO<T1, T2>, f2: IO<T2, O>): F<I, O>;\r\n\r\nexport declare function pipe<I extends any[], T1, T2, T3, O>(f0: F<I, T1>, f1: IO<T1, T2>, f2: IO<T2, T3>, f3: IO<T3, O>): F<I, O>;\r\n\r\nexport declare function pipe<I extends any[], T1, T2, T3, T4, O>(f0: F<I, T1>, f1: IO<T1, T2>, f2: IO<T2, T3>, f3: IO<T3, T4>, f4: IO<T4, O>): F<I, O>;\r\n\r\n/**\r\n * `\"%f,%f('!')?\"` representing the point (x,y).\r\n *\r\n * The optional `'!'` indicates the node position should not change (input-only).\r\n *\r\n * If dim=3, point may also have the format `\"%f,%f,%f('!')?\"` to represent the point (x,y,z).\r\n * @group Attribute Types\r\n */\r\nexport declare type Point = Point.position | `${Point.position}!`;\r\n\r\n/** @hidden */\r\nexport declare namespace Point {\r\n    export type position = `${Double},${Double}` | `${Double},${Double},${Double}` | `${Double},${Double},${Double},${Double},${Double}` | `${Double},${Double},${Double},${Double},${Double},${Double}` | `${Double},${Double},${Double},${Double},${Double},${Double},${Double}` | `${Double},${Double},${Double},${Double},${Double},${Double},${Double},${Double}` | `${Double},${Double},${Double},${Double},${Double},${Double},${Double},${Double},${Double}` | `${Double},${Double},${Double},${Double},${Double},${Double},${Double},${Double},${Double},${number}`;\r\n}\r\n\r\n/**\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/pointList/ pointList}\r\n * @group Attribute Types\r\n */\r\nexport declare type PointList = Point | `${Point} ${Point}` | `${Point} ${Point} ${Point}` | `${Point} ${Point} ${Point} ${Point}`;\r\n\r\n/**\r\n * Port on an edge node.\r\n * @group Models\r\n */\r\nexport declare interface Port {\r\n    port: string;\r\n    compass: Compass;\r\n}\r\n\r\n/**\r\n * Port Position\r\n *\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/portPos/ portPos}\r\n * @group Attribute Types\r\n */\r\nexport declare type PortPos = `${string}:${Compass}` | Compass;\r\n\r\n/**\r\n * Using `\"fast\"` gives about a 2-4 times overall speedup compared with `\"normal\"`,\r\n * though layout quality can suffer a little.\r\n *\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/quadType/ quadType}\r\n * @group Attribute Types\r\n */\r\nexport declare type QuadType = QuadType.values;\r\n\r\n/** @hidden */\r\nexport declare namespace QuadType {\r\n    export type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\r\n    export interface $values extends $keywords<'normal' | 'fast' | 'none'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/**\r\n * Rank Direction\r\n *\r\n * Corresponding to directed graphs drawn from top to bottom,\r\n * from left to right, from bottom to top, and from right to left, respectively.\r\n *\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/rankdir/ rankdir}\r\n * @group Attribute Types\r\n */\r\nexport declare type Rankdir = 'TB' | 'BT' | 'LR' | 'RL';\r\n\r\n/**\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/rankType/ rankType}\r\n * @group Attribute Types\r\n */\r\nexport declare type RankType = RankType.values;\r\n\r\n/** @hidden */\r\nexport declare namespace RankType {\r\n    export type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\r\n    export interface $values extends $keywords<'same' | 'min' | 'source' | 'max' | 'sink'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/**\r\n * `\"%f,%f,%f,%f\"`\r\n *\r\n * The rectangle `llx,lly,urx,ury` gives the coordinates, in points,\r\n * of the lower-left corner `(llx,lly)` and the upper-right corner `(urx,ury)`.\r\n *\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/rect/ rect}\r\n * @group Attribute Types\r\n */\r\nexport declare type Rect = `${Double},${Double},${Double},${Double}`;\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare interface RootGraphConstructor {\r\n    new (id?: string, attributes?: GraphAttributesObject): RootGraphModel;\r\n    new (id?: string, strict?: boolean, attributes?: GraphAttributesObject): RootGraphModel;\r\n    new (strict?: boolean, attributes?: GraphAttributesObject): RootGraphModel;\r\n    new (attributes?: GraphAttributesObject): RootGraphModel;\r\n    new (...args: any[]): RootGraphModel;\r\n}\r\n\r\n/**\r\n * DOT model representing a root graphs(digraph and graph).\r\n * @group Models\r\n */\r\nexport declare interface RootGraphModel extends GraphBaseModel<GraphAttributeKey>, DotObjectModel<'Graph'> {\r\n    directed: boolean;\r\n    /**\r\n     * Strict mode.\r\n     *\r\n     * @description\r\n     * A graph may also be described as strict.\r\n     * This forbids the creation of multi-edges, i.e., there can be at most one edge with a given tail node and head node in the directed case.\r\n     * For undirected graphs, there can be at most one edge connected to the same two nodes.\r\n     * Subsequent edge statements using the same two nodes will identify the edge with the previously defined one and apply any attributes given in the edge statement.\r\n     */\r\n    strict: boolean;\r\n}\r\n\r\n/**\r\n * @group Models Context\r\n */\r\nexport declare const RootModelsContext: ModelsContext;\r\n\r\n/**\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/shape/ shape}\r\n * @group Attribute Types\r\n */\r\nexport declare type Shape = string;\r\n\r\nexport declare namespace Side {\r\n    export type T = 'T';\r\n    export type B = 'B';\r\n    export type R = 'R';\r\n    export type L = 'L';\r\n    export type Combinations = T | B | R | L | `${T}${B}` | `${T}${R}` | `${T}${L}` | `${B}${R}` | `${B}${L}` | `${R}${L}` | `${T}${B}${R}` | `${T}${B}${L}` | `${T}${R}${L}` | `${B}${R}${L}` | `${T}${B}${R}${L}`;\r\n}\r\n\r\n/**\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/smoothType/ smoothType}\r\n * @group Attribute Types\r\n */\r\nexport declare type SmoothType = SmoothType.values;\r\n\r\n/** @hidden */\r\nexport declare namespace SmoothType {\r\n    export type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\r\n    export interface $values extends $keywords<'none' | 'avg_dist' | 'graph_dist' | 'power_dist' | 'rng' | 'spring' | 'triangle'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/**\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/splineType/ splineType}\r\n * @group Attribute Types\r\n */\r\nexport declare type SplineType = SplineType.spline | string;\r\n\r\n/** @hidden */\r\nexport declare namespace SplineType {\r\n    export type prefix = endp | startp | `${endp}${startp}` | '';\r\n    export type spline = `${prefix}point ${triple}`;\r\n    export type triple = `${Point} ${Point} ${Point}`;\r\n    export type endp = `e,${Double},${Double} `;\r\n    export type startp = `s,${Double},${Double} `;\r\n}\r\n\r\n/**\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/startType/ startType}\r\n * @group Attribute Types\r\n */\r\nexport declare type StartType = `${StartType.style}${StartType.seed}`;\r\n\r\n/** @hidden */\r\nexport declare namespace StartType {\r\n    export type style = Exclude<keyof $style, keyof $exclude>;\r\n    export interface $style extends $keywords<'regular' | 'self' | 'random'> {\r\n    }\r\n    export type seed = number;\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/**\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/style/ style}\r\n * @group Attribute Types\r\n */\r\nexport declare type Style = Style.styleItem | `${Style.styleItem},${Style.styleItem}` | `${Style.styleItem},${Style.styleItem},${Style.styleItem}` | `${Style.styleItem},${Style.styleItem},${Style.styleItem},${Style.styleItem}`;\r\n\r\n/** @hidden */\r\nexport declare namespace Style {\r\n    export type styleItem = Exclude<keyof $styleItem, keyof $exclude>;\r\n    export interface $styleItem extends $keywords<'dashed' | 'dotted' | 'solid' | 'invis' | 'bold' | 'tapered' | 'filled' | 'striped' | 'wedged' | 'diagonals' | 'rounded' | 'filled' | 'striped' | 'rounded' | 'radial'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/**\r\n * Attribute types available for subgraph.\r\n * @group Attribute\r\n */\r\nexport declare type SubgraphAttributeKey = SubgraphAttributeKey.values;\r\n\r\n/** @hidden */\r\nexport declare namespace SubgraphAttributeKey {\r\n    export type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\r\n    export interface $values extends $keywords<'rank'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/**\r\n * Attribute object that can be set to Subgraph.\r\n * @group Models\r\n */\r\nexport declare type SubgraphAttributesObject = AttributesObject<ClusterSubgraphAttributeKey | SubgraphAttributeKey>;\r\n\r\n/**\r\n * @group Models\r\n */\r\nexport declare interface SubgraphConstructor {\r\n    new (id?: string, attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    new (attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    new (...args: any[]): SubgraphModel;\r\n}\r\n\r\n/**\r\n * DOT model representing a subgraph.\r\n * @group Models\r\n */\r\nexport declare interface SubgraphModel extends GraphBaseModel<SubgraphAttributeKey | ClusterSubgraphAttributeKey>, DotObjectModel<'Subgraph'> {\r\n    /** Determines whether the Subgraph is a SubgraphCluster. */\r\n    isSubgraphCluster(): boolean;\r\n}\r\n\r\n/**\r\n * Which rank to move floating (loose) nodes to\r\n *\r\n * Valid options:\r\n * - \"min\": Move floating (loose) nodes to minimum rank.\r\n * - \"max\": Move floating (loose) nodes to maximum rank.\r\n * - Otherwise, floating nodes are placed anywhere.\r\n *\r\n * Despite the name TBbalance (\"Top-Bottom Balance\"), this also works with left-right ranks, e.g. rankdir=LR.\r\n *\r\n * @see {@link https://graphviz.org/docs/attrs/TBbalance/ TBbalance}\r\n * @group Attribute Types\r\n */\r\nexport declare type TBbalanceType = TBbalanceType.values;\r\n\r\n/** @hidden */\r\nexport declare namespace TBbalanceType {\r\n    export type values = Exclude<keyof $values, keyof $exclude | symbol | number>;\r\n    export interface $values extends $keywords<'min' | 'max'> {\r\n    }\r\n    export interface $exclude extends $keywordsValidation {\r\n    }\r\n}\r\n\r\n/** @hidden */\r\nexport declare function toNodeRef(target: NodeRefLike): NodeRef;\r\n\r\n/** @hidden */\r\nexport declare function toNodeRefGroup(targets: NodeRefGroupLike): NodeRefGroup;\r\n\r\n/**\r\n * @see {@link https://graphviz.gitlab.io/docs/attr-types/viewPort/ viewPort}\r\n * @group Attribute Types\r\n */\r\nexport declare type ViewPort = `${Double},${Double},${Double},${Double},${Double}` | `${Double},${Double},${Double},${string}`;\r\n\r\nexport { }\r\n"},{"filePath":"file:///node_modules/@ts-graphviz/ast/package.json","content":"{\"name\":\"@ts-graphviz/ast\",\"types\":\"lib/ast.d.ts\"}"},{"filePath":"file:///node_modules/@ts-graphviz/ast/lib/ast.d.ts","content":"import { ASTType } from '@ts-graphviz/common';\r\nimport { AttributeKey } from '@ts-graphviz/common';\r\nimport { Compass } from '@ts-graphviz/common';\r\nimport { DotObjectModel } from '@ts-graphviz/common';\r\nimport { EdgeModel } from '@ts-graphviz/common';\r\nimport { ModelsContext } from '@ts-graphviz/common';\r\nimport { NodeModel } from '@ts-graphviz/common';\r\nimport { RootGraphModel } from '@ts-graphviz/common';\r\nimport { SubgraphModel } from '@ts-graphviz/common';\r\n\r\ndeclare interface AnyExpectation {\r\n    type: \"any\";\r\n}\r\n\r\n/**\r\n * ASTBaseNode is an interface that serves as the base for all AST nodes.\r\n * It requires all leaf interfaces to specify a type property,\r\n * which is of type {@link ASTType}.\r\n *\r\n * @group AST\r\n */\r\nexport declare interface ASTBaseNode {\r\n    /**\r\n     * Every leaf interface that extends ASTBaseNode\r\n     * must specify a type property.\r\n     */\r\n    type: ASTType;\r\n}\r\n\r\n/**\r\n * ASTBaseParentNode represents a parent node that has some child nodes.\r\n *\r\n * @template STMT The type of {@link ASTBaseNode} to be stored in the children array.\r\n * @group AST\r\n */\r\nexport declare interface ASTBaseParentNode<STMT extends ASTBaseNode = ASTBaseNode> extends ASTBaseNode {\r\n    children: STMT[];\r\n}\r\n\r\n/**\r\n * This interface provides an ASTBuilder object with a createElement function.\r\n * @group Create AST\r\n */\r\nexport declare interface ASTBuilder {\r\n    createElement: CreateElement;\r\n}\r\n\r\n/**\r\n * ASTChildNode is a type alias used to represent the child nodes of a given {@link ASTBaseParentNode}.\r\n * @group AST\r\n */\r\nexport declare type ASTChildNode<T> = T extends ASTBaseParentNode<infer C> ? C : never;\r\n\r\n/**\r\n * This interface provides common properties to be used across all abstract syntax tree (AST) objects.\r\n *\r\n * @group AST\r\n */\r\nexport declare interface ASTCommonPropaties {\r\n    /**\r\n     * The start and end location of the AST object.\r\n     */\r\n    location?: FileRange;\r\n}\r\n\r\n/**\r\n * ASTNode is a type used to define a set of different types of AST nodes that can be used in a graph.\r\n *\r\n * @group AST\r\n */\r\nexport declare type ASTNode = LiteralASTNode | DotASTNode | GraphASTNode | AttributeASTNode | CommentASTNode | AttributeListASTNode | NodeRefASTNode | NodeRefGroupASTNode | EdgeASTNode | NodeASTNode | SubgraphASTNode;\r\n\r\n/**\r\n * ASTToModel is a type that determines a model type from an AST.\r\n *\r\n * @group AST\r\n */\r\nexport declare type ASTToModel<T> = T extends {\r\n    type: infer U;\r\n} ? ModelOf<U> : never;\r\n\r\n/**\r\n * AttributeASTNode is a type of AST node that represents an attribute.\r\n * @group AST\r\n */\r\nexport declare interface AttributeASTNode<T extends AttributeKey = AttributeKey> extends ASTBaseParentNode<never>, AttributeASTPropaties<T> {\r\n    type: 'Attribute';\r\n}\r\n\r\n/**\r\n * AttributeASTPropaties interface defines the properties of an {@link AttributeASTNode}.\r\n * @group AST\r\n */\r\nexport declare interface AttributeASTPropaties<T extends AttributeKey = AttributeKey> extends ASTCommonPropaties {\r\n    key: LiteralASTNode<T>;\r\n    value: LiteralASTNode;\r\n}\r\n\r\n/**\r\n * AttributeListASTNode is a type of AST node that represents a list of attributes.\r\n * @group AST\r\n */\r\nexport declare interface AttributeListASTNode extends ASTBaseParentNode<AttributeASTNode | CommentASTNode>, AttributeListASTPropaties {\r\n    type: 'AttributeList';\r\n}\r\n\r\n/**\r\n * AttributeListASTPropaties interface defines the properties of an {@link AttributeListASTNode}.\r\n * @group AST\r\n */\r\nexport declare interface AttributeListASTPropaties extends ASTCommonPropaties {\r\n    kind: 'Graph' | 'Edge' | 'Node';\r\n}\r\n\r\n/**\r\n * Builder is an ASTBuilder that provides a method to create an ASTNode.\r\n *\r\n * @group Create AST\r\n */\r\nexport declare class Builder implements ASTBuilder {\r\n    private options?;\r\n    /* Excluded from this release type: getLocation */\r\n    /**\r\n     * Constructor of Builder\r\n     * @param options - Options to initialize Builder\r\n     */\r\n    constructor(options?: Partial<BuilderOptions> | undefined);\r\n    /**\r\n     * Create an {@link ASTNode} of the specified type\r\n     *\r\n     * @param type - Type of the {@link ASTNode}\r\n     * @param props - Properties of the {@link ASTNode}\r\n     * @param children - Children of the {@link ASTNode}\r\n     * @returns An {@link ASTNode}\r\n     */\r\n    createElement<T extends ASTNode>(type: T['type'], props: any, children?: ASTChildNode<T>[]): T;\r\n}\r\n\r\n/**\r\n * This interface is used to define the options for the builder.\r\n *\r\n * @group Create AST\r\n */\r\nexport declare interface BuilderOptions {\r\n    /**\r\n     * This is a function that returns a {@link FileRange} object.\r\n     * It is used to specify the location of the builder.\r\n     */\r\n    locationFunction: () => FileRange;\r\n}\r\n\r\ndeclare interface ClassExpectation {\r\n    type: \"class\";\r\n    parts: ClassParts;\r\n    inverted: boolean;\r\n    ignoreCase: boolean;\r\n}\r\n\r\ndeclare interface ClassParts extends Array<string | ClassParts> {\r\n}\r\n\r\n/**\r\n * ClusterStatementASTNode is a type used to represent a statement in a cluster graph.\r\n * @group AST\r\n */\r\nexport declare type ClusterStatementASTNode = AttributeASTNode | AttributeListASTNode | EdgeASTNode | NodeASTNode | SubgraphASTNode | CommentASTNode;\r\n\r\n/**\r\n * CommentASTNode is a type of AST node that represents a comment.\r\n * @group AST\r\n */\r\nexport declare interface CommentASTNode extends ASTBaseParentNode<never>, CommentASTPropaties {\r\n    type: 'Comment';\r\n}\r\n\r\n/**\r\n * @group AST\r\n */\r\nexport declare interface CommentASTPropaties extends ASTCommonPropaties {\r\n    /**\r\n     * A string that specifies the kind of comment.\r\n     */\r\n    kind: CommentKind;\r\n    /**\r\n     * A string that contains the actual content of the comment.\r\n     */\r\n    value: string;\r\n}\r\n\r\n/**\r\n * CommentKind is an enum type that describes a type of comment.\r\n *\r\n * @group AST\r\n */\r\nexport declare type CommentKind = 'Block' | 'Slash' | 'Macro';\r\n\r\n/**\r\n * CommonParseOptions is an interface that defines the properties needed in order to parse a file.\r\n * @group Convert DOT to AST\r\n */\r\nexport declare interface CommonParseOptions {\r\n    /**\r\n     * filename (optional): A string value that is used to identify the file to be parsed.\r\n     */\r\n    filename?: string;\r\n}\r\n\r\n/**\r\n * @group Convert Model to AST\r\n */\r\nexport declare interface ConvertFromModelContext extends Required<ConvertFromModelOptions> {\r\n    convert<T extends DotObjectModel>(model: T): ModelToAST<T>;\r\n}\r\n\r\n/**\r\n * @group Convert Model to AST\r\n */\r\nexport declare interface ConvertFromModelOptions {\r\n    commentKind?: CommentKind;\r\n}\r\n\r\n/**\r\n * @group Convert Model to AST\r\n */\r\nexport declare interface ConvertFromModelPlugin<T extends DotObjectModel> {\r\n    match(model: T): boolean;\r\n    convert(context: ConvertFromModelContext, model: T): ModelToAST<T>;\r\n}\r\n\r\n/**\r\n * @group Convert AST to Model\r\n */\r\nexport declare interface ConvertToModelContext {\r\n    models: ModelsContext;\r\n    convert<T extends ToModelConvertableASTNode>(ast: T): ASTToModel<T>;\r\n}\r\n\r\n/**\r\n * @group Convert AST to Model\r\n */\r\nexport declare interface ConvertToModelOptions {\r\n    models?: Partial<ModelsContext>;\r\n}\r\n\r\n/**\r\n * @group Convert AST to Model\r\n */\r\nexport declare interface ConvertToModelPlugin<T extends ToModelConvertableASTNode = ToModelConvertableASTNode> {\r\n    match(ast: T): boolean;\r\n    convert(context: ConvertToModelContext, ast: T): ASTToModel<T>;\r\n}\r\n\r\n/**\r\n * This interface provides a method for creating an Abstract Syntax Tree (AST) for a given type.\r\n * @group Create AST\r\n */\r\nexport declare interface CreateElement {\r\n    /**\r\n     * Creates a LiteralASTNode with the given type, properties, and children.\r\n     *\r\n     * @param type The type of the AST node.\r\n     * @param props The properties of the AST node.\r\n     * @param children The children of the AST node.\r\n     * @returns A {@link LiteralASTNode} with the given type, properties, and children.\r\n     */\r\n    <T extends string>(type: 'Literal', props: LiteralASTPropaties<T>, children?: ASTChildNode<LiteralASTNode>[]): LiteralASTNode<T>;\r\n    /**\r\n     * Creates a LiteralASTNode with the given type, properties, and children.\r\n     *\r\n     * @param type The type of the AST node.\r\n     * @param props The properties of the AST node.\r\n     * @param children The children of the AST node.\r\n     * @returns A {@link LiteralASTNode} with the given type, properties, and children.\r\n     */\r\n    (type: 'Literal', props: LiteralASTPropaties, children?: ASTChildNode<LiteralASTNode>[]): LiteralASTNode;\r\n    /**\r\n     * Creates a {@link DotASTNode} with the given type, properties, and children.\r\n     *\r\n     * @param type The type of the AST node.\r\n     * @param props The properties of the AST node.\r\n     * @param children The children of the AST node.\r\n     * @returns A {@link DotASTNode} with the given type, properties, and children.\r\n     */\r\n    (type: 'Dot', props: DotASTPropaties, children?: ASTChildNode<DotASTNode>[]): DotASTNode;\r\n    /**\r\n     * Creates a {@link GraphASTNode} with the given type, properties, and children.\r\n     *\r\n     * @param type The type of the AST node.\r\n     * @param props The properties of the AST node.\r\n     * @param children The children of the AST node.\r\n     * @returns A {GraphASTNode} with the given type, properties, and children.\r\n     */\r\n    (type: 'Graph', props: GraphASTPropaties, children?: ASTChildNode<GraphASTNode>[]): GraphASTNode;\r\n    /**\r\n     * Creates an {@link AttributeASTNode} with the given type, properties, and children.\r\n     *\r\n     * @param type The type of the AST node.\r\n     * @param props The properties of the AST node.\r\n     * @param children The children of the AST node.\r\n     * @returns An {@link AttributeASTNode} with the given type, properties, and children.\r\n     */\r\n    <K extends AttributeKey>(type: 'Attribute', props: AttributeASTPropaties<K>, children?: ASTChildNode<AttributeASTNode>[]): AttributeASTNode<K>;\r\n    (type: 'Attribute', props: AttributeASTPropaties, children?: ASTChildNode<AttributeASTNode>[]): AttributeASTNode;\r\n    /**\r\n     * Creates a {@link CommentASTNode} with the given type, properties, and children.\r\n     *\r\n     * @param type The type of the AST node.\r\n     * @param props The properties of the AST node.\r\n     * @param children The children of the AST node.\r\n     * @returns A {@link CommentASTNode} with the given type, properties, and children.\r\n     */\r\n    (type: 'Comment', props: CommentASTPropaties, children?: ASTChildNode<CommentASTNode>[]): CommentASTNode;\r\n    /**\r\n     * Creates an {@link AttributeListASTNode} with the given type, properties, and children.\r\n     *\r\n     * @param type The type of the AST node.\r\n     * @param props The properties of the AST node.\r\n     * @param children The children of the AST node.\r\n     * @returns An {@link AttributeListASTNode} with the given type, properties, and children.\r\n     */\r\n    (type: 'AttributeList', props: AttributeListASTPropaties, children?: ASTChildNode<AttributeListASTNode>[]): AttributeListASTNode;\r\n    /**\r\n     * Creates a {@link NodeRefASTNode} with the given type, properties, and children.\r\n     *\r\n     * @param type The type of the AST node.\r\n     * @param props The properties of the AST node.\r\n     * @param children The children of the AST node.\r\n     * @returns A {@link NodeRefASTNode} with the given type, properties, and children.\r\n     */\r\n    (type: 'NodeRef', props: NodeRefASTPropaties, children?: ASTChildNode<NodeRefASTNode>[]): NodeRefASTNode;\r\n    /**\r\n     * Creates a {@link NodeRefGroupASTNode} with the given type, properties, and children.\r\n     *\r\n     * @param type The type of the AST node.\r\n     * @param props The properties of the AST node.\r\n     * @param children The children of the AST node.\r\n     * @returns A {@link NodeRefGroupASTNode} with the given type, properties, and children.\r\n     */\r\n    (type: 'NodeRefGroup', props: NodeRefGroupASTPropaties, children?: ASTChildNode<NodeRefGroupASTNode>[]): NodeRefGroupASTNode;\r\n    /**\r\n     * Creates an {@link EdgeASTNode} with the given type, properties, and children.\r\n     *\r\n     * @param type The type of the AST node.\r\n     * @param props The properties of the AST node.\r\n     * @param children The children of the AST node.\r\n     * @returns An {@link EdgeASTNode} with the given type, properties, and children.\r\n     */\r\n    (type: 'Edge', props: EdgeASTPropaties, children?: ASTChildNode<EdgeASTNode>[]): EdgeASTNode;\r\n    /**\r\n     * Creates a {@link NodeASTNode} with the given type, properties, and children.\r\n     *\r\n     * @param type The type of the AST node.\r\n     * @param props The properties of the AST node.\r\n     * @param children The children of the AST node.\r\n     * @returns A {@link NodeASTNode} with the given type, properties, and children.\r\n     */\r\n    (type: 'Node', props: NodeASTPropaties, children?: ASTChildNode<NodeASTNode>[]): NodeASTNode;\r\n    /**\r\n     * Creates a {@link SubgraphASTNode} with the given type, properties, and children.\r\n     *\r\n     * @param type The type of the AST node.\r\n     * @param props The properties of the AST node.\r\n     * @param children The children of the AST node.\r\n     * @returns A {@link SubgraphASTNode} with the given type, properties, and children.\r\n     */\r\n    (type: 'Subgraph', props: SubgraphASTPropaties, children?: ASTChildNode<SubgraphASTNode>[]): SubgraphASTNode;\r\n}\r\n\r\n/**\r\n * Create an {@link ASTNode} of the specified type\r\n *\r\n * @param type - Type of the {@link ASTNode}\r\n * @param props - Properties of the {@link ASTNode}\r\n * @param children - Children of the {@link ASTNode}\r\n * @group Create AST\r\n * @returns An {@link ASTNode}\r\n */\r\nexport declare const createElement: CreateElement;\r\n\r\n/**\r\n * DotASTNode is a type of AST node that represents a dot in a graph.\r\n *\r\n * @group AST\r\n */\r\nexport declare interface DotASTNode extends ASTBaseParentNode<StatementASTNode>, DotASTPropaties {\r\n    type: 'Dot';\r\n}\r\n\r\n/**\r\n * This interface represents the properties of a dot AST node.\r\n * @group AST\r\n */\r\nexport declare interface DotASTPropaties extends ASTCommonPropaties {\r\n}\r\n\r\n/**\r\n * @group Convert DOT to AST\r\n */\r\nexport declare class DotSyntaxError extends PeggySyntaxError {\r\n    constructor(...args: ConstructorParameters<typeof PeggySyntaxError>);\r\n}\r\n\r\n/**\r\n * EdgeASTNode is a type of AST node that represents an edge in a graph.\r\n * @group AST\r\n */\r\nexport declare interface EdgeASTNode extends ASTBaseParentNode<AttributeASTNode | CommentASTNode>, EdgeASTPropaties {\r\n    type: 'Edge';\r\n}\r\n\r\n/**\r\n * EdgeASTPropaties is an interface that defines the properties of an {@link EdgeASTNode}.\r\n * @group AST\r\n */\r\nexport declare interface EdgeASTPropaties extends ASTCommonPropaties {\r\n    /**\r\n     * An array of EdgeTargetASTNodes.\r\n     * The {@link EdgeTargetASTNode} represents a node that is the target of an edge.\r\n     */\r\n    targets: [\r\n    from: EdgeTargetASTNode,\r\n    to: EdgeTargetASTNode,\r\n    ...rest: EdgeTargetASTNode[]\r\n    ];\r\n}\r\n\r\n/**\r\n * This type is used to represent a target of an edge in an AST (Abstract Syntax Tree).\r\n *\r\n * @group AST\r\n */\r\nexport declare type EdgeTargetASTNode = NodeRefASTNode | NodeRefGroupASTNode;\r\n\r\ndeclare interface EndExpectation {\r\n    type: \"end\";\r\n}\r\n\r\n/**\r\n * This type represents the EndOfLine type which is used to determine the type of line ending to be used when writing to a file.\r\n * @group Convert AST to DOT\r\n */\r\nexport declare type EndOfLine = 'lf' | 'crlf';\r\n\r\ndeclare type Expectation = LiteralExpectation | ClassExpectation | AnyExpectation | EndExpectation | OtherExpectation;\r\n\r\n/**\r\n * The FilePosition interface represents the position of a file in terms of its offset, line number, and column number.\r\n *\r\n * @group AST\r\n */\r\nexport declare interface FilePosition {\r\n    /**\r\n     * The offset of the file.\r\n     */\r\n    offset: number;\r\n    /**\r\n     * The line number of the file.\r\n     */\r\n    line: number;\r\n    /**\r\n     * The column number of the file.\r\n     */\r\n    column: number;\r\n}\r\n\r\ndeclare interface FilePosition_2 {\r\n    offset: number;\r\n    line: number;\r\n    column: number;\r\n}\r\n\r\n/**\r\n * FileRange interface represents a range of positions within a file.\r\n * @group AST\r\n */\r\nexport declare interface FileRange {\r\n    /**\r\n     * The start position of the range.\r\n     */\r\n    start: FilePosition;\r\n    /**\r\n     * The end position of the range.\r\n     */\r\n    end: FilePosition;\r\n}\r\n\r\ndeclare interface FileRange_2 {\r\n    start: FilePosition_2;\r\n    end: FilePosition_2;\r\n    source: string;\r\n}\r\n\r\n/**\r\n * A function used to convert a DotObjectModel into an AST.\r\n *\r\n * @param model - The {@link DotObjectModel} to be converted.\r\n * @param options - An optional {@link ConvertFromModelOptions} object.\r\n * @returns ModelToAST - The AST representation of the {@link DotObjectModel}.\r\n *\r\n * @group Convert Model to AST\r\n */\r\nexport declare function fromModel<T extends DotObjectModel>(model: T, options?: ConvertFromModelOptions): ModelToAST<T>;\r\n\r\n/**\r\n * FromModelConverter is a class used to convert a {@link DotObjectModel} into an ASTNode.\r\n *\r\n * @group Convert Model to AST\r\n */\r\nexport declare class FromModelConverter {\r\n    #private;\r\n    private options;\r\n    constructor(options?: ConvertFromModelOptions);\r\n    /**\r\n     * Converts a DotObjectModel into an AST.\r\n     *\r\n     * @param model The {@link DotObjectModel} to be converted.\r\n     * @returns The AST generated from the model.\r\n     */\r\n    convert<T extends DotObjectModel>(model: T): ModelToAST<T>;\r\n}\r\n\r\n/**\r\n * GraphASTNode is a type of AST node that represents a graph.\r\n *\r\n * @group AST\r\n */\r\nexport declare interface GraphASTNode extends ASTBaseParentNode<ClusterStatementASTNode>, GraphASTPropaties {\r\n    type: 'Graph';\r\n}\r\n\r\n/**\r\n * This interface defines the properties of a Graph AST Node.\r\n * @group AST\r\n */\r\nexport declare interface GraphASTPropaties extends ASTCommonPropaties {\r\n    /**\r\n     * An optional identifier for the Graph AST Node.\r\n     */\r\n    id?: LiteralASTNode;\r\n    /**\r\n     * A boolean indicating whether the graph is directed.\r\n     */\r\n    directed: boolean;\r\n    /**\r\n     * A boolean indicating whether the graph is strict.\r\n     */\r\n    strict: boolean;\r\n}\r\n\r\n/**\r\n * The IndentStyle type represents an indentation style for text. It can either be a `\"space\"` or a `\"tab\"`.\r\n * @group Convert AST to DOT\r\n */\r\nexport declare type IndentStyle = 'space' | 'tab';\r\n\r\n/**\r\n * LiteralASTNode is a type of AST node that represents a literal value.\r\n *\r\n * @group AST\r\n */\r\nexport declare interface LiteralASTNode<T extends string = string> extends ASTBaseParentNode<never>, LiteralASTPropaties<T> {\r\n    type: 'Literal';\r\n}\r\n\r\n/**\r\n * LiteralASTPropaties defines interface for literal AST nodes.\r\n *\r\n * @group AST\r\n */\r\nexport declare interface LiteralASTPropaties<T extends string = string> extends ASTCommonPropaties {\r\n    /**\r\n     * The value of the literal.\r\n     */\r\n    value: T;\r\n    /**\r\n     * A flag indicating whether the literal was quoted or not.\r\n     * If 'html' then the literal is an html like value.\r\n     */\r\n    quoted: boolean | 'html';\r\n}\r\n\r\ndeclare interface LiteralExpectation {\r\n    type: \"literal\";\r\n    text: string;\r\n    ignoreCase: boolean;\r\n}\r\n\r\n/**\r\n *  ModelOf is a type that determines the type of model to use depending on the value of T.\r\n * @group AST\r\n */\r\nexport declare type ModelOf<T> = T extends 'Dot' | 'Graph' ? RootGraphModel : T extends 'Edge' ? EdgeModel : T extends 'Node' ? NodeModel : T extends 'Subgraph' ? SubgraphModel : never;\r\n\r\n/**\r\n * ModelToAST is a type alias used to map a generic type T to a specific AST node type.\r\n *\r\n * If T is a DotObjectModel, the type U is inferred and used to determine which AST node type to map to.\r\n *\r\n * If U is 'Graph', the type is mapped to either a {@link GraphASTNode} or a {@link DotASTNode}.\r\n * If U is 'AttributeList', the type is mapped to an {@link AttributeListASTNode}.\r\n * If U is 'Edge', the type is mapped to an {@link EdgeASTNode}.\r\n * If U is 'Node', the type is mapped to a {@link NodeASTNode}.\r\n * If U is 'Subgraph', the type is mapped to a {@link SubgraphASTNode}.\r\n *\r\n * If T is not a DotObjectModel, the type is mapped to never.\r\n *\r\n * @group AST\r\n */\r\nexport declare type ModelToAST<T> = T extends DotObjectModel<infer U> ? U extends 'Graph' ? GraphASTNode | DotASTNode : U extends 'AttributeList' ? AttributeListASTNode : U extends 'Edge' ? EdgeASTNode : U extends 'Node' ? NodeASTNode : U extends 'Subgraph' ? SubgraphASTNode : never : never;\r\n\r\n/**\r\n * NodeASTNode is a type of AST node that represents a node in a graph.\r\n * @group AST\r\n */\r\nexport declare interface NodeASTNode extends ASTBaseParentNode<AttributeASTNode | CommentASTNode>, NodeASTPropaties {\r\n    type: 'Node';\r\n}\r\n\r\n/**\r\n * SubgraphASTPropaties describes the properties of an AST node representing a node.\r\n * @group AST\r\n */\r\nexport declare interface NodeASTPropaties extends ASTCommonPropaties {\r\n    /**\r\n     * The unique identifier of the node.\r\n     */\r\n    id: LiteralASTNode;\r\n}\r\n\r\n/**\r\n * NodeRefASTNode is a type of AST node that represents a reference to a node.\r\n * @group AST\r\n */\r\nexport declare interface NodeRefASTNode extends ASTBaseParentNode<never>, NodeRefASTPropaties {\r\n    type: 'NodeRef';\r\n}\r\n\r\n/**\r\n * NodeRefASTPropaties is an interface that defines the properties of a {@link NodeRefASTNode}.\r\n * @group AST\r\n */\r\nexport declare interface NodeRefASTPropaties extends ASTCommonPropaties {\r\n    id: LiteralASTNode;\r\n    port?: LiteralASTNode;\r\n    compass?: LiteralASTNode<Compass>;\r\n}\r\n\r\n/**\r\n * NodeRefGroupASTNode is a type of AST node that represents a group of nodes referenced together.\r\n * @group AST\r\n */\r\nexport declare interface NodeRefGroupASTNode extends ASTBaseParentNode<NodeRefASTNode>, NodeRefGroupASTPropaties {\r\n    type: 'NodeRefGroup';\r\n}\r\n\r\n/**\r\n * NodeRefGroupASTPropaties is an interface that defines the properties of a {@link NodeRefGroupASTNode}.\r\n * @group AST\r\n */\r\nexport declare interface NodeRefGroupASTPropaties extends ASTCommonPropaties {\r\n}\r\n\r\ndeclare interface OtherExpectation {\r\n    type: \"other\";\r\n    description: string;\r\n}\r\n\r\n/**\r\n * parse is a function that takes a string input and optional parse options and\r\n * returns an ASTNode or an array of ClusterStatementASTNodes.\r\n *\r\n * Depending on the type of parse option specified, the function will return different types of ASTNodes.\r\n *\r\n * The types of ASTNodes that can be returned are:\r\n *\r\n * - {@link DotASTNode}\r\n * - {@link GraphASTNode}\r\n * - {@link NodeASTNode}\r\n * - {@link EdgeASTNode}\r\n * - {@link AttributeListASTNode}\r\n * - {@link AttributeASTNode}\r\n * - {@link SubgraphASTNode}\r\n * - {@link ClusterStatementASTNode}\r\n *\r\n * @throws {@link SyntaxError}\r\n     * @group Convert DOT to AST\r\n     */\r\n export declare function parse(input: string): DotASTNode;\r\n\r\n export declare function parse(input: string, options?: ParseOptions<'Dot'>): DotASTNode;\r\n\r\n export declare function parse(input: string, options?: ParseOptions<'Graph'>): GraphASTNode;\r\n\r\n export declare function parse(input: string, options?: ParseOptions<'Node'>): NodeASTNode;\r\n\r\n export declare function parse(input: string, options?: ParseOptions<'Edge'>): EdgeASTNode;\r\n\r\n export declare function parse(input: string, options?: ParseOptions<'AttributeList'>): AttributeListASTNode;\r\n\r\n export declare function parse(input: string, options?: ParseOptions<'Attribute'>): AttributeASTNode;\r\n\r\n export declare function parse(input: string, options?: ParseOptions<'Subgraph'>): SubgraphASTNode;\r\n\r\n export declare function parse(input: string, options?: ParseOptions<'ClusterStatements'>): ClusterStatementASTNode[];\r\n\r\n export declare function parse(input: string, options?: ParseOptions<Rule>): ASTNode | ClusterStatementASTNode[];\r\n\r\n /**\r\n  * ParseOptions interface is used to provide additional information to the parser while parsing a rule.\r\n  * @template T The type of the rule to be parsed.\r\n  * @group Convert DOT to AST\r\n  */\r\n export declare interface ParseOptions<T extends Rule> extends CommonParseOptions {\r\n     startRule?: T;\r\n }\r\n\r\n declare const PeggySyntaxError: typeof _PeggySyntaxError;\r\n\r\n declare type PeggySyntaxError = _PeggySyntaxError;\r\n\r\n declare class _PeggySyntaxError extends Error {\r\n     static buildMessage(expected: Expectation[], found: string | null): string;\r\n     message: string;\r\n     expected: Expectation[];\r\n     found: string | null;\r\n     location: FileRange_2;\r\n     name: string;\r\n     constructor(message: string, expected: Expectation[], found: string | null, location: FileRange_2);\r\n     format(sources: {\r\n         source?: any;\r\n         text: string;\r\n     }[]): string;\r\n }\r\n\r\n /**\r\n  * PrintContext interface provides an interface for printing an ASTNode with a set of options.\r\n  * @group Convert AST to DOT\r\n  */\r\n export declare interface PrintContext extends Required<PrintOptions> {\r\n     /**\r\n      * Indicates if the AST should be printed in a directed graph.\r\n      */\r\n     directed: boolean;\r\n     /**\r\n      * A function to print an ASTNode, taking in an ASTNode as an argument. Returns a string.\r\n      */\r\n     print(ast: ASTNode): string;\r\n }\r\n\r\n /**\r\n  * Printer is a class responsible for converting an AST into a DOT string.\r\n  * @group Convert AST to DOT\r\n  */\r\n export declare class Printer {\r\n     #private;\r\n     private options;\r\n     /**\r\n      * @param options Options to be used when generating the DOT string.\r\n      */\r\n     constructor(options?: PrintOptions);\r\n     /**\r\n      * Generates a DOT string from an ASTNode.\r\n      * @param ast The ASTNode to be converted into a DOT string.\r\n      * @returns The DOT string generated from the ASTNode.\r\n      */\r\n     print(ast: ASTNode): string;\r\n }\r\n\r\n /**\r\n  * This interface provides options for converting an abstract syntax tree (AST) to a DOT representation.\r\n  * @group Convert AST to DOT\r\n  */\r\n export declare interface PrintOptions {\r\n     /**\r\n      * The style of indentation to use when printing the AST.\r\n      *\r\n      * @default \"space\"\r\n      */\r\n     indentStyle?: IndentStyle;\r\n     /**\r\n      * The size of the indentation to use when printing the AST.\r\n      *\r\n      * @default 2\r\n      */\r\n     indentSize?: number;\r\n     /**\r\n      * The type of line ending to use when printing the AST.\r\n      *\r\n      * @default lf\r\n      */\r\n     endOfLine?: EndOfLine;\r\n }\r\n\r\n /**\r\n  * PrintPlugin is an interface for plugins used for printing an {@link ASTNode}.\r\n  * @template T T extends {@link ASTNode}\r\n  * @group Convert AST to DOT\r\n  */\r\n export declare interface PrintPlugin<T extends ASTNode = ASTNode> {\r\n     /**\r\n      * Checks if an ASTNode matches the plugin\r\n      * @returns {boolean} true if the ASTNode matches the plugin\r\n      */\r\n     match(ast: ASTNode): boolean;\r\n     /**\r\n      * Prints an ASTNode\r\n      * @param context PrintContext object\r\n      * @param ast an ASTNode\r\n      * @returns printed string\r\n      * @memberof PrintPlugin\r\n      */\r\n     print(context: PrintContext, ast: T): string;\r\n }\r\n\r\n /**\r\n  * @group Convert DOT to AST\r\n  */\r\n export declare type Rule = 'Dot' | 'Graph' | 'Node' | 'Edge' | 'AttributeList' | 'Attribute' | 'Subgraph' | 'ClusterStatements';\r\n\r\n /**\r\n  * @group AST\r\n  */\r\n export declare type StatementASTNode = GraphASTNode | CommentASTNode;\r\n\r\n /**\r\n  * stringify is a function that converts a Graphviz AST Node into a string in DOT language.\r\n  *\r\n  * @param ast Graphviz AST node that is to be converted.\r\n  * @param options PrintOptions object containing formatting options.\r\n  * @returns A string in DOT language.\r\n  * @group Convert AST to DOT\r\n  */\r\n export declare function stringify(ast: ASTNode, options?: PrintOptions): string;\r\n\r\n /**\r\n  * SubgraphASTNode is a type of AST node that represents a subgraph.\r\n  * @group AST\r\n  */\r\n export declare interface SubgraphASTNode extends ASTBaseParentNode<ClusterStatementASTNode>, SubgraphASTPropaties {\r\n     type: 'Subgraph';\r\n }\r\n\r\n /**\r\n  * SubgraphASTPropaties describes the properties of an AST node representing a subgraph.\r\n  * @group AST\r\n  */\r\n export declare interface SubgraphASTPropaties extends ASTCommonPropaties {\r\n     /**\r\n      * id is an optional {@link LiteralASTNode} that represents the identifier of the subgraph.\r\n      */\r\n     id?: LiteralASTNode;\r\n }\r\n\r\n /**\r\n  * @group Convert AST to Model\r\n  */\r\n export declare function toModel<T extends ToModelConvertableASTNode>(ast: T, options?: ConvertToModelOptions): ASTToModel<T>;\r\n\r\n /**\r\n  * This type is used to define what AST nodes can be converted to a model.\r\n  * @group Convert AST to Model\r\n  */\r\n export declare type ToModelConvertableASTNode = DotASTNode | GraphASTNode | SubgraphASTNode | NodeASTNode | EdgeASTNode;\r\n\r\n /**\r\n  * @group Convert AST to Model\r\n  */\r\n export declare class ToModelConverter {\r\n     private options;\r\n     /** @hidden */\r\n     protected plugins: ConvertToModelPlugin<ToModelConvertableASTNode>[];\r\n     constructor(options?: ConvertToModelOptions);\r\n     /**\r\n      * Convert AST to Model.\r\n      *\r\n      * @param ast AST node.\r\n      */\r\n     convert<T extends ToModelConvertableASTNode>(ast: T): ASTToModel<T>;\r\n }\r\n\r\n export { }\r\n"},{"filePath":"file:///node_modules/@ts-graphviz/core/package.json","content":"{\"name\":\"@ts-graphviz/core\",\"types\":\"lib/core.d.ts\"}"},{"filePath":"file:///node_modules/@ts-graphviz/core/lib/AttributeList.d.ts","content":"import { Attribute } from '@ts-graphviz/common';\r\nimport { AttributeKey } from '@ts-graphviz/common';\r\nimport { AttributeListKind } from '@ts-graphviz/common';\r\nimport { AttributeListModel } from '@ts-graphviz/common';\r\nimport { Attributes } from '@ts-graphviz/common';\r\nimport { AttributesEntities } from '@ts-graphviz/common';\r\nimport { AttributesObject } from '@ts-graphviz/common';\r\n\r\n/**\r\n * A set of attribute values for any object.\r\n * @group Models\r\n */\r\nexport declare class AttributeList<K extends AttributeListKind, T extends AttributeKey = AttributeKey> extends AttributesBase<T> implements AttributeListModel<K, T> {\r\n    readonly $$kind: K;\r\n    get $$type(): 'AttributeList';\r\n    comment?: string;\r\n    constructor($$kind: K, attributes?: AttributesObject<T>);\r\n}\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase<T extends AttributeKey> extends DotObject implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject {\r\n}\r\n\r\nexport { }\r\n"},{"filePath":"file:///node_modules/@ts-graphviz/core/lib/AttributesBase.d.ts","content":"import { Attribute } from '@ts-graphviz/common';\r\nimport { AttributeKey } from '@ts-graphviz/common';\r\nimport { Attributes } from '@ts-graphviz/common';\r\nimport { AttributesEntities } from '@ts-graphviz/common';\r\nimport { AttributesObject } from '@ts-graphviz/common';\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\nexport declare abstract class AttributesBase<T extends AttributeKey> extends DotObject implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject {\r\n}\r\n\r\nexport { }\r\n"},{"filePath":"file:///node_modules/@ts-graphviz/core/lib/AttributesGroup.d.ts","content":"import { Attribute } from '@ts-graphviz/common';\r\nimport { AttributeKey } from '@ts-graphviz/common';\r\nimport { Attributes } from '@ts-graphviz/common';\r\nimport { AttributesEntities } from '@ts-graphviz/common';\r\nimport { AttributesGroupModel } from '@ts-graphviz/common';\r\nimport { AttributesObject } from '@ts-graphviz/common';\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase<T extends AttributeKey> extends DotObject implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * A set of attribute values for any object.\r\n * @group Models\r\n */\r\nexport declare class AttributesGroup<T extends AttributeKey = AttributeKey> extends AttributesBase<T> implements AttributesGroupModel<T> {\r\n    comment?: string;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject {\r\n}\r\n\r\nexport { }\r\n"},{"filePath":"file:///node_modules/@ts-graphviz/core/lib/Digraph.d.ts","content":"import { Attribute } from '@ts-graphviz/common';\r\nimport { AttributeKey } from '@ts-graphviz/common';\r\nimport { Attributes } from '@ts-graphviz/common';\r\nimport { AttributesEntities } from '@ts-graphviz/common';\r\nimport { AttributesObject } from '@ts-graphviz/common';\r\nimport { EdgeAttributesObject } from '@ts-graphviz/common';\r\nimport { EdgeModel } from '@ts-graphviz/common';\r\nimport { EdgeTargetLikeTuple } from '@ts-graphviz/common';\r\nimport { GraphAttributeKey } from '@ts-graphviz/common';\r\nimport { GraphAttributesObject } from '@ts-graphviz/common';\r\nimport { GraphBaseModel } from '@ts-graphviz/common';\r\nimport { GraphCommonAttributes } from '@ts-graphviz/common';\r\nimport { ModelsContext } from '@ts-graphviz/common';\r\nimport { NodeAttributesObject } from '@ts-graphviz/common';\r\nimport { NodeModel } from '@ts-graphviz/common';\r\nimport { RootGraphModel } from '@ts-graphviz/common';\r\nimport { SubgraphAttributesObject } from '@ts-graphviz/common';\r\nimport { SubgraphModel } from '@ts-graphviz/common';\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase<T extends AttributeKey> extends DotObject implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * DOT object class representing a digraph.\r\n * @group Models\r\n */\r\nexport declare class Digraph extends RootGraph {\r\n    get directed(): boolean;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject {\r\n}\r\n\r\n/**\r\n * Base class for Graph objects.\r\n * @group Models\r\n */\r\ndeclare abstract class GraphBase<T extends AttributeKey> extends AttributesBase<T> implements GraphBaseModel<T> {\r\n    #private;\r\n    readonly id?: string;\r\n    comment?: string;\r\n    readonly attributes: Readonly<GraphCommonAttributes>;\r\n    get nodes(): ReadonlyArray<NodeModel>;\r\n    get edges(): ReadonlyArray<EdgeModel>;\r\n    get subgraphs(): ReadonlyArray<SubgraphModel>;\r\n    with(models: Partial<ModelsContext>): void;\r\n    addNode(node: NodeModel): void;\r\n    addEdge(edge: EdgeModel): void;\r\n    addSubgraph(subgraph: SubgraphModel): void;\r\n    existNode(nodeId: string): boolean;\r\n    existEdge(edge: EdgeModel): boolean;\r\n    existSubgraph(subgraph: SubgraphModel): boolean;\r\n    createSubgraph(id?: string, attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    createSubgraph(attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    removeNode(node: NodeModel | string): void;\r\n    removeEdge(edge: EdgeModel): void;\r\n    removeSubgraph(subgraph: SubgraphModel): void;\r\n    createNode(id: string, attributes?: NodeAttributesObject): NodeModel;\r\n    getSubgraph(id: string): SubgraphModel | undefined;\r\n    getNode(id: string): NodeModel | undefined;\r\n    createEdge(targets: EdgeTargetLikeTuple, attributes?: EdgeAttributesObject): EdgeModel;\r\n    subgraph(id: string, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(id: string, attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    node(id: string, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(id: string, attributes: NodeAttributesObject, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(attributes: NodeAttributesObject): void;\r\n    edge(targets: EdgeTargetLikeTuple, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(targets: EdgeTargetLikeTuple, attributes: EdgeAttributesObject, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(attributes: EdgeAttributesObject): void;\r\n    graph(attributes: SubgraphAttributesObject): void;\r\n}\r\n\r\n/**\r\n * Base class representing a root graph(digraph, graph).\r\n * @group Models\r\n */\r\ndeclare abstract class RootGraph extends GraphBase<GraphAttributeKey> implements RootGraphModel {\r\n    get $$type(): 'Graph';\r\n    readonly id?: string;\r\n    abstract readonly directed: boolean;\r\n    strict: boolean;\r\n    constructor(id?: string, attributes?: GraphAttributesObject);\r\n    constructor(id?: string, strict?: boolean, attributes?: GraphAttributesObject);\r\n    constructor(strict?: boolean, attributes?: GraphAttributesObject);\r\n    constructor(attributes?: GraphAttributesObject);\r\n}\r\n\r\nexport { }\r\n"},{"filePath":"file:///node_modules/@ts-graphviz/core/lib/DotObject.d.ts","content":"/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\nexport declare abstract class DotObject {\r\n}\r\n\r\nexport { }\r\n"},{"filePath":"file:///node_modules/@ts-graphviz/core/lib/Edge.d.ts","content":"import { AttributesGroupModel } from '@ts-graphviz/common';\r\nimport { EdgeAttributeKey } from '@ts-graphviz/common';\r\nimport { EdgeAttributesObject } from '@ts-graphviz/common';\r\nimport { EdgeModel } from '@ts-graphviz/common';\r\nimport { EdgeTargetTuple } from '@ts-graphviz/common';\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject {\r\n}\r\n\r\n/**\r\n * DOT object class representing a edge.\r\n * @group Models\r\n */\r\nexport declare class Edge extends DotObject implements EdgeModel {\r\n    readonly targets: EdgeTargetTuple;\r\n    get $$type(): 'Edge';\r\n    comment?: string;\r\n    readonly attributes: AttributesGroupModel<EdgeAttributeKey>;\r\n    constructor(targets: EdgeTargetTuple, attributes?: EdgeAttributesObject);\r\n}\r\n\r\nexport { }\r\n"},{"filePath":"file:///node_modules/@ts-graphviz/core/lib/Graph.d.ts","content":"import { Attribute } from '@ts-graphviz/common';\r\nimport { AttributeKey } from '@ts-graphviz/common';\r\nimport { Attributes } from '@ts-graphviz/common';\r\nimport { AttributesEntities } from '@ts-graphviz/common';\r\nimport { AttributesObject } from '@ts-graphviz/common';\r\nimport { EdgeAttributesObject } from '@ts-graphviz/common';\r\nimport { EdgeModel } from '@ts-graphviz/common';\r\nimport { EdgeTargetLikeTuple } from '@ts-graphviz/common';\r\nimport { GraphAttributeKey } from '@ts-graphviz/common';\r\nimport { GraphAttributesObject } from '@ts-graphviz/common';\r\nimport { GraphBaseModel } from '@ts-graphviz/common';\r\nimport { GraphCommonAttributes } from '@ts-graphviz/common';\r\nimport { ModelsContext } from '@ts-graphviz/common';\r\nimport { NodeAttributesObject } from '@ts-graphviz/common';\r\nimport { NodeModel } from '@ts-graphviz/common';\r\nimport { RootGraphModel } from '@ts-graphviz/common';\r\nimport { SubgraphAttributesObject } from '@ts-graphviz/common';\r\nimport { SubgraphModel } from '@ts-graphviz/common';\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase<T extends AttributeKey> extends DotObject implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject {\r\n}\r\n\r\n/**\r\n * DOT object class representing a graph.\r\n * @group Models\r\n */\r\nexport declare class Graph extends RootGraph {\r\n    get directed(): boolean;\r\n}\r\n\r\n/**\r\n * Base class for Graph objects.\r\n * @group Models\r\n */\r\ndeclare abstract class GraphBase<T extends AttributeKey> extends AttributesBase<T> implements GraphBaseModel<T> {\r\n    #private;\r\n    readonly id?: string;\r\n    comment?: string;\r\n    readonly attributes: Readonly<GraphCommonAttributes>;\r\n    get nodes(): ReadonlyArray<NodeModel>;\r\n    get edges(): ReadonlyArray<EdgeModel>;\r\n    get subgraphs(): ReadonlyArray<SubgraphModel>;\r\n    with(models: Partial<ModelsContext>): void;\r\n    addNode(node: NodeModel): void;\r\n    addEdge(edge: EdgeModel): void;\r\n    addSubgraph(subgraph: SubgraphModel): void;\r\n    existNode(nodeId: string): boolean;\r\n    existEdge(edge: EdgeModel): boolean;\r\n    existSubgraph(subgraph: SubgraphModel): boolean;\r\n    createSubgraph(id?: string, attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    createSubgraph(attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    removeNode(node: NodeModel | string): void;\r\n    removeEdge(edge: EdgeModel): void;\r\n    removeSubgraph(subgraph: SubgraphModel): void;\r\n    createNode(id: string, attributes?: NodeAttributesObject): NodeModel;\r\n    getSubgraph(id: string): SubgraphModel | undefined;\r\n    getNode(id: string): NodeModel | undefined;\r\n    createEdge(targets: EdgeTargetLikeTuple, attributes?: EdgeAttributesObject): EdgeModel;\r\n    subgraph(id: string, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(id: string, attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    node(id: string, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(id: string, attributes: NodeAttributesObject, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(attributes: NodeAttributesObject): void;\r\n    edge(targets: EdgeTargetLikeTuple, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(targets: EdgeTargetLikeTuple, attributes: EdgeAttributesObject, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(attributes: EdgeAttributesObject): void;\r\n    graph(attributes: SubgraphAttributesObject): void;\r\n}\r\n\r\n/**\r\n * Base class representing a root graph(digraph, graph).\r\n * @group Models\r\n */\r\ndeclare abstract class RootGraph extends GraphBase<GraphAttributeKey> implements RootGraphModel {\r\n    get $$type(): 'Graph';\r\n    readonly id?: string;\r\n    abstract readonly directed: boolean;\r\n    strict: boolean;\r\n    constructor(id?: string, attributes?: GraphAttributesObject);\r\n    constructor(id?: string, strict?: boolean, attributes?: GraphAttributesObject);\r\n    constructor(strict?: boolean, attributes?: GraphAttributesObject);\r\n    constructor(attributes?: GraphAttributesObject);\r\n}\r\n\r\nexport { }\r\n"},{"filePath":"file:///node_modules/@ts-graphviz/core/lib/GraphBase.d.ts","content":"import { Attribute } from '@ts-graphviz/common';\r\nimport { AttributeKey } from '@ts-graphviz/common';\r\nimport { Attributes } from '@ts-graphviz/common';\r\nimport { AttributesEntities } from '@ts-graphviz/common';\r\nimport { AttributesObject } from '@ts-graphviz/common';\r\nimport { EdgeAttributesObject } from '@ts-graphviz/common';\r\nimport { EdgeModel } from '@ts-graphviz/common';\r\nimport { EdgeTargetLikeTuple } from '@ts-graphviz/common';\r\nimport { GraphBaseModel } from '@ts-graphviz/common';\r\nimport { GraphCommonAttributes } from '@ts-graphviz/common';\r\nimport { ModelsContext } from '@ts-graphviz/common';\r\nimport { NodeAttributesObject } from '@ts-graphviz/common';\r\nimport { NodeModel } from '@ts-graphviz/common';\r\nimport { SubgraphAttributesObject } from '@ts-graphviz/common';\r\nimport { SubgraphModel } from '@ts-graphviz/common';\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase<T extends AttributeKey> extends DotObject implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject {\r\n}\r\n\r\n/**\r\n * Base class for Graph objects.\r\n * @group Models\r\n */\r\nexport declare abstract class GraphBase<T extends AttributeKey> extends AttributesBase<T> implements GraphBaseModel<T> {\r\n    #private;\r\n    readonly id?: string;\r\n    comment?: string;\r\n    readonly attributes: Readonly<GraphCommonAttributes>;\r\n    get nodes(): ReadonlyArray<NodeModel>;\r\n    get edges(): ReadonlyArray<EdgeModel>;\r\n    get subgraphs(): ReadonlyArray<SubgraphModel>;\r\n    with(models: Partial<ModelsContext>): void;\r\n    addNode(node: NodeModel): void;\r\n    addEdge(edge: EdgeModel): void;\r\n    addSubgraph(subgraph: SubgraphModel): void;\r\n    existNode(nodeId: string): boolean;\r\n    existEdge(edge: EdgeModel): boolean;\r\n    existSubgraph(subgraph: SubgraphModel): boolean;\r\n    createSubgraph(id?: string, attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    createSubgraph(attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    removeNode(node: NodeModel | string): void;\r\n    removeEdge(edge: EdgeModel): void;\r\n    removeSubgraph(subgraph: SubgraphModel): void;\r\n    createNode(id: string, attributes?: NodeAttributesObject): NodeModel;\r\n    getSubgraph(id: string): SubgraphModel | undefined;\r\n    getNode(id: string): NodeModel | undefined;\r\n    createEdge(targets: EdgeTargetLikeTuple, attributes?: EdgeAttributesObject): EdgeModel;\r\n    subgraph(id: string, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(id: string, attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    node(id: string, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(id: string, attributes: NodeAttributesObject, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(attributes: NodeAttributesObject): void;\r\n    edge(targets: EdgeTargetLikeTuple, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(targets: EdgeTargetLikeTuple, attributes: EdgeAttributesObject, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(attributes: EdgeAttributesObject): void;\r\n    graph(attributes: SubgraphAttributesObject): void;\r\n}\r\n\r\nexport { }\r\n"},{"filePath":"file:///node_modules/@ts-graphviz/core/lib/Node.d.ts","content":"import { Attribute } from '@ts-graphviz/common';\r\nimport { AttributeKey } from '@ts-graphviz/common';\r\nimport { Attributes } from '@ts-graphviz/common';\r\nimport { AttributesEntities } from '@ts-graphviz/common';\r\nimport { AttributesGroupModel } from '@ts-graphviz/common';\r\nimport { AttributesObject } from '@ts-graphviz/common';\r\nimport { ForwardRefNode } from '@ts-graphviz/common';\r\nimport { NodeAttributeKey } from '@ts-graphviz/common';\r\nimport { NodeAttributesObject } from '@ts-graphviz/common';\r\nimport { NodeModel } from '@ts-graphviz/common';\r\nimport { Port } from '@ts-graphviz/common';\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase<T extends AttributeKey> extends DotObject_2 implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * A set of attribute values for any object.\r\n * @group Models\r\n */\r\ndeclare class AttributesGroup<T extends AttributeKey = AttributeKey> extends AttributesBase<T> implements AttributesGroupModel<T> {\r\n    comment?: string;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject {\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject_2 {\r\n}\r\n\r\n/**\r\n * DOT object class representing a node.\r\n * @group Models\r\n */\r\nexport declare class Node extends DotObject implements NodeModel {\r\n    readonly id: string;\r\n    get $$type(): 'Node';\r\n    comment?: string;\r\n    readonly attributes: AttributesGroup<NodeAttributeKey>;\r\n    constructor(id: string, attributes?: NodeAttributesObject);\r\n    port(port: string | Partial<Port>): ForwardRefNode;\r\n}\r\n\r\nexport { }\r\n"},{"filePath":"file:///node_modules/@ts-graphviz/core/lib/RootGraph.d.ts","content":"import { Attribute } from '@ts-graphviz/common';\r\nimport { AttributeKey } from '@ts-graphviz/common';\r\nimport { Attributes } from '@ts-graphviz/common';\r\nimport { AttributesEntities } from '@ts-graphviz/common';\r\nimport { AttributesObject } from '@ts-graphviz/common';\r\nimport { EdgeAttributesObject } from '@ts-graphviz/common';\r\nimport { EdgeModel } from '@ts-graphviz/common';\r\nimport { EdgeTargetLikeTuple } from '@ts-graphviz/common';\r\nimport { GraphAttributeKey } from '@ts-graphviz/common';\r\nimport { GraphAttributesObject } from '@ts-graphviz/common';\r\nimport { GraphBaseModel } from '@ts-graphviz/common';\r\nimport { GraphCommonAttributes } from '@ts-graphviz/common';\r\nimport { ModelsContext } from '@ts-graphviz/common';\r\nimport { NodeAttributesObject } from '@ts-graphviz/common';\r\nimport { NodeModel } from '@ts-graphviz/common';\r\nimport { RootGraphModel } from '@ts-graphviz/common';\r\nimport { SubgraphAttributesObject } from '@ts-graphviz/common';\r\nimport { SubgraphModel } from '@ts-graphviz/common';\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase<T extends AttributeKey> extends DotObject implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject {\r\n}\r\n\r\n/**\r\n * Base class for Graph objects.\r\n * @group Models\r\n */\r\ndeclare abstract class GraphBase<T extends AttributeKey> extends AttributesBase<T> implements GraphBaseModel<T> {\r\n    #private;\r\n    readonly id?: string;\r\n    comment?: string;\r\n    readonly attributes: Readonly<GraphCommonAttributes>;\r\n    get nodes(): ReadonlyArray<NodeModel>;\r\n    get edges(): ReadonlyArray<EdgeModel>;\r\n    get subgraphs(): ReadonlyArray<SubgraphModel>;\r\n    with(models: Partial<ModelsContext>): void;\r\n    addNode(node: NodeModel): void;\r\n    addEdge(edge: EdgeModel): void;\r\n    addSubgraph(subgraph: SubgraphModel): void;\r\n    existNode(nodeId: string): boolean;\r\n    existEdge(edge: EdgeModel): boolean;\r\n    existSubgraph(subgraph: SubgraphModel): boolean;\r\n    createSubgraph(id?: string, attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    createSubgraph(attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    removeNode(node: NodeModel | string): void;\r\n    removeEdge(edge: EdgeModel): void;\r\n    removeSubgraph(subgraph: SubgraphModel): void;\r\n    createNode(id: string, attributes?: NodeAttributesObject): NodeModel;\r\n    getSubgraph(id: string): SubgraphModel | undefined;\r\n    getNode(id: string): NodeModel | undefined;\r\n    createEdge(targets: EdgeTargetLikeTuple, attributes?: EdgeAttributesObject): EdgeModel;\r\n    subgraph(id: string, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(id: string, attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    node(id: string, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(id: string, attributes: NodeAttributesObject, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(attributes: NodeAttributesObject): void;\r\n    edge(targets: EdgeTargetLikeTuple, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(targets: EdgeTargetLikeTuple, attributes: EdgeAttributesObject, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(attributes: EdgeAttributesObject): void;\r\n    graph(attributes: SubgraphAttributesObject): void;\r\n}\r\n\r\n/**\r\n * Base class representing a root graph(digraph, graph).\r\n * @group Models\r\n */\r\nexport declare abstract class RootGraph extends GraphBase<GraphAttributeKey> implements RootGraphModel {\r\n    get $$type(): 'Graph';\r\n    readonly id?: string;\r\n    abstract readonly directed: boolean;\r\n    strict: boolean;\r\n    constructor(id?: string, attributes?: GraphAttributesObject);\r\n    constructor(id?: string, strict?: boolean, attributes?: GraphAttributesObject);\r\n    constructor(strict?: boolean, attributes?: GraphAttributesObject);\r\n    constructor(attributes?: GraphAttributesObject);\r\n}\r\n\r\nexport { }\r\n"},{"filePath":"file:///node_modules/@ts-graphviz/core/lib/Subgraph.d.ts","content":"import { Attribute } from '@ts-graphviz/common';\r\nimport { AttributeKey } from '@ts-graphviz/common';\r\nimport { Attributes } from '@ts-graphviz/common';\r\nimport { AttributesEntities } from '@ts-graphviz/common';\r\nimport { AttributesObject } from '@ts-graphviz/common';\r\nimport { ClusterSubgraphAttributeKey } from '@ts-graphviz/common';\r\nimport { EdgeAttributesObject } from '@ts-graphviz/common';\r\nimport { EdgeModel } from '@ts-graphviz/common';\r\nimport { EdgeTargetLikeTuple } from '@ts-graphviz/common';\r\nimport { GraphBaseModel } from '@ts-graphviz/common';\r\nimport { GraphCommonAttributes } from '@ts-graphviz/common';\r\nimport { ModelsContext } from '@ts-graphviz/common';\r\nimport { NodeAttributesObject } from '@ts-graphviz/common';\r\nimport { NodeModel } from '@ts-graphviz/common';\r\nimport { SubgraphAttributeKey } from '@ts-graphviz/common';\r\nimport { SubgraphAttributesObject } from '@ts-graphviz/common';\r\nimport { SubgraphModel } from '@ts-graphviz/common';\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase<T extends AttributeKey> extends DotObject implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject {\r\n}\r\n\r\n/**\r\n * Base class for Graph objects.\r\n * @group Models\r\n */\r\ndeclare abstract class GraphBase<T extends AttributeKey> extends AttributesBase<T> implements GraphBaseModel<T> {\r\n    #private;\r\n    readonly id?: string;\r\n    comment?: string;\r\n    readonly attributes: Readonly<GraphCommonAttributes>;\r\n    get nodes(): ReadonlyArray<NodeModel>;\r\n    get edges(): ReadonlyArray<EdgeModel>;\r\n    get subgraphs(): ReadonlyArray<SubgraphModel>;\r\n    with(models: Partial<ModelsContext>): void;\r\n    addNode(node: NodeModel): void;\r\n    addEdge(edge: EdgeModel): void;\r\n    addSubgraph(subgraph: SubgraphModel): void;\r\n    existNode(nodeId: string): boolean;\r\n    existEdge(edge: EdgeModel): boolean;\r\n    existSubgraph(subgraph: SubgraphModel): boolean;\r\n    createSubgraph(id?: string, attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    createSubgraph(attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    removeNode(node: NodeModel | string): void;\r\n    removeEdge(edge: EdgeModel): void;\r\n    removeSubgraph(subgraph: SubgraphModel): void;\r\n    createNode(id: string, attributes?: NodeAttributesObject): NodeModel;\r\n    getSubgraph(id: string): SubgraphModel | undefined;\r\n    getNode(id: string): NodeModel | undefined;\r\n    createEdge(targets: EdgeTargetLikeTuple, attributes?: EdgeAttributesObject): EdgeModel;\r\n    subgraph(id: string, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(id: string, attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    node(id: string, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(id: string, attributes: NodeAttributesObject, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(attributes: NodeAttributesObject): void;\r\n    edge(targets: EdgeTargetLikeTuple, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(targets: EdgeTargetLikeTuple, attributes: EdgeAttributesObject, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(attributes: EdgeAttributesObject): void;\r\n    graph(attributes: SubgraphAttributesObject): void;\r\n}\r\n\r\n/**\r\n * DOT object class representing a subgraph.\r\n * @group Models\r\n */\r\nexport declare class Subgraph extends GraphBase<SubgraphAttributeKey | ClusterSubgraphAttributeKey> implements SubgraphModel {\r\n    get $$type(): 'Subgraph';\r\n    readonly id?: string;\r\n    constructor(id?: string, attributes?: SubgraphAttributesObject);\r\n    constructor(attributes?: SubgraphAttributesObject);\r\n    isSubgraphCluster(): boolean;\r\n}\r\n\r\nexport { }\r\n"},{"filePath":"file:///node_modules/@ts-graphviz/core/lib/core.d.ts","content":"import { Attribute } from '@ts-graphviz/common';\r\nimport { AttributeKey } from '@ts-graphviz/common';\r\nimport { AttributeListKind } from '@ts-graphviz/common';\r\nimport { AttributeListModel } from '@ts-graphviz/common';\r\nimport { Attributes } from '@ts-graphviz/common';\r\nimport { AttributesEntities } from '@ts-graphviz/common';\r\nimport { AttributesGroupModel } from '@ts-graphviz/common';\r\nimport { AttributesObject } from '@ts-graphviz/common';\r\nimport { ClusterSubgraphAttributeKey } from '@ts-graphviz/common';\r\nimport { EdgeAttributeKey } from '@ts-graphviz/common';\r\nimport { EdgeAttributesObject } from '@ts-graphviz/common';\r\nimport { EdgeModel } from '@ts-graphviz/common';\r\nimport { EdgeTargetLikeTuple } from '@ts-graphviz/common';\r\nimport { EdgeTargetTuple } from '@ts-graphviz/common';\r\nimport { ForwardRefNode } from '@ts-graphviz/common';\r\nimport { GraphAttributeKey } from '@ts-graphviz/common';\r\nimport { GraphAttributesObject } from '@ts-graphviz/common';\r\nimport { GraphBaseModel } from '@ts-graphviz/common';\r\nimport { GraphCommonAttributes } from '@ts-graphviz/common';\r\nimport { ModelsContext } from '@ts-graphviz/common';\r\nimport { NodeAttributeKey } from '@ts-graphviz/common';\r\nimport { NodeAttributesObject } from '@ts-graphviz/common';\r\nimport { NodeModel } from '@ts-graphviz/common';\r\nimport { Port } from '@ts-graphviz/common';\r\nimport { RootGraphModel } from '@ts-graphviz/common';\r\nimport { SubgraphAttributeKey } from '@ts-graphviz/common';\r\nimport { SubgraphAttributesObject } from '@ts-graphviz/common';\r\nimport { SubgraphModel } from '@ts-graphviz/common';\r\n\r\n/**\r\n * A set of attribute values for any object.\r\n * @group Models\r\n */\r\nexport declare class AttributeList<K extends AttributeListKind, T extends AttributeKey = AttributeKey> extends AttributesBase_2<T> implements AttributeListModel<K, T> {\r\n    readonly $$kind: K;\r\n    get $$type(): 'AttributeList';\r\n    comment?: string;\r\n    constructor($$kind: K, attributes?: AttributesObject<T>);\r\n}\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\nexport declare abstract class AttributesBase<T extends AttributeKey> extends DotObject_3 implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase_2<T extends AttributeKey> extends DotObject_2 implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase_3<T extends AttributeKey> extends DotObject_4 implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase_4<T extends AttributeKey> extends DotObject_5 implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase_5<T extends AttributeKey> extends DotObject_7 implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase_6<T extends AttributeKey> extends DotObject_8 implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase_7<T extends AttributeKey> extends DotObject_2_2 implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase_8<T extends AttributeKey> extends DotObject_10 implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects with attributes.\r\n * @group Models\r\n */\r\ndeclare abstract class AttributesBase_9<T extends AttributeKey> extends DotObject_11 implements Attributes<T> {\r\n    #private;\r\n    constructor(attributes?: AttributesObject<T>);\r\n    get values(): ReadonlyArray<[T, Attribute<T>]>;\r\n    get size(): number;\r\n    get<K extends T>(key: K): Attribute<K> | undefined;\r\n    set<K extends T>(key: K, value: Attribute<K>): void;\r\n    delete(key: T): void;\r\n    apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;\r\n    clear(): void;\r\n}\r\n\r\n/**\r\n * A set of attribute values for any object.\r\n * @group Models\r\n */\r\nexport declare class AttributesGroup<T extends AttributeKey = AttributeKey> extends AttributesBase_3<T> implements AttributesGroupModel<T> {\r\n    comment?: string;\r\n}\r\n\r\n/**\r\n * A set of attribute values for any object.\r\n * @group Models\r\n */\r\ndeclare class AttributesGroup_2<T extends AttributeKey = AttributeKey> extends AttributesBase_7<T> implements AttributesGroupModel<T> {\r\n    comment?: string;\r\n}\r\n\r\n/**\r\n * DOT object class representing a digraph.\r\n * @group Models\r\n */\r\nexport declare class Digraph extends RootGraph_2 {\r\n    get directed(): boolean;\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\nexport declare abstract class DotObject {\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject_10 {\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject_11 {\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject_2 {\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject_2_2 {\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject_3 {\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject_4 {\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject_5 {\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject_6 {\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject_7 {\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject_8 {\r\n}\r\n\r\n/**\r\n * Base class for DOT objects.\r\n * @group Models\r\n */\r\ndeclare abstract class DotObject_9 {\r\n}\r\n\r\n/**\r\n * DOT object class representing a edge.\r\n * @group Models\r\n */\r\nexport declare class Edge extends DotObject_6 implements EdgeModel {\r\n    readonly targets: EdgeTargetTuple;\r\n    get $$type(): 'Edge';\r\n    comment?: string;\r\n    readonly attributes: AttributesGroupModel<EdgeAttributeKey>;\r\n    constructor(targets: EdgeTargetTuple, attributes?: EdgeAttributesObject);\r\n}\r\n\r\n/**\r\n * DOT object class representing a graph.\r\n * @group Models\r\n */\r\nexport declare class Graph extends RootGraph_3 {\r\n    get directed(): boolean;\r\n}\r\n\r\n/**\r\n * Base class for Graph objects.\r\n * @group Models\r\n */\r\nexport declare abstract class GraphBase<T extends AttributeKey> extends AttributesBase_6<T> implements GraphBaseModel<T> {\r\n    #private;\r\n    readonly id?: string;\r\n    comment?: string;\r\n    readonly attributes: Readonly<GraphCommonAttributes>;\r\n    get nodes(): ReadonlyArray<NodeModel>;\r\n    get edges(): ReadonlyArray<EdgeModel>;\r\n    get subgraphs(): ReadonlyArray<SubgraphModel>;\r\n    with(models: Partial<ModelsContext>): void;\r\n    addNode(node: NodeModel): void;\r\n    addEdge(edge: EdgeModel): void;\r\n    addSubgraph(subgraph: SubgraphModel): void;\r\n    existNode(nodeId: string): boolean;\r\n    existEdge(edge: EdgeModel): boolean;\r\n    existSubgraph(subgraph: SubgraphModel): boolean;\r\n    createSubgraph(id?: string, attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    createSubgraph(attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    removeNode(node: NodeModel | string): void;\r\n    removeEdge(edge: EdgeModel): void;\r\n    removeSubgraph(subgraph: SubgraphModel): void;\r\n    createNode(id: string, attributes?: NodeAttributesObject): NodeModel;\r\n    getSubgraph(id: string): SubgraphModel | undefined;\r\n    getNode(id: string): NodeModel | undefined;\r\n    createEdge(targets: EdgeTargetLikeTuple, attributes?: EdgeAttributesObject): EdgeModel;\r\n    subgraph(id: string, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(id: string, attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    node(id: string, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(id: string, attributes: NodeAttributesObject, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(attributes: NodeAttributesObject): void;\r\n    edge(targets: EdgeTargetLikeTuple, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(targets: EdgeTargetLikeTuple, attributes: EdgeAttributesObject, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(attributes: EdgeAttributesObject): void;\r\n    graph(attributes: SubgraphAttributesObject): void;\r\n}\r\n\r\n/**\r\n * Base class for Graph objects.\r\n * @group Models\r\n */\r\ndeclare abstract class GraphBase_2<T extends AttributeKey> extends AttributesBase_4<T> implements GraphBaseModel<T> {\r\n    #private;\r\n    readonly id?: string;\r\n    comment?: string;\r\n    readonly attributes: Readonly<GraphCommonAttributes>;\r\n    get nodes(): ReadonlyArray<NodeModel>;\r\n    get edges(): ReadonlyArray<EdgeModel>;\r\n    get subgraphs(): ReadonlyArray<SubgraphModel>;\r\n    with(models: Partial<ModelsContext>): void;\r\n    addNode(node: NodeModel): void;\r\n    addEdge(edge: EdgeModel): void;\r\n    addSubgraph(subgraph: SubgraphModel): void;\r\n    existNode(nodeId: string): boolean;\r\n    existEdge(edge: EdgeModel): boolean;\r\n    existSubgraph(subgraph: SubgraphModel): boolean;\r\n    createSubgraph(id?: string, attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    createSubgraph(attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    removeNode(node: NodeModel | string): void;\r\n    removeEdge(edge: EdgeModel): void;\r\n    removeSubgraph(subgraph: SubgraphModel): void;\r\n    createNode(id: string, attributes?: NodeAttributesObject): NodeModel;\r\n    getSubgraph(id: string): SubgraphModel | undefined;\r\n    getNode(id: string): NodeModel | undefined;\r\n    createEdge(targets: EdgeTargetLikeTuple, attributes?: EdgeAttributesObject): EdgeModel;\r\n    subgraph(id: string, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(id: string, attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    node(id: string, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(id: string, attributes: NodeAttributesObject, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(attributes: NodeAttributesObject): void;\r\n    edge(targets: EdgeTargetLikeTuple, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(targets: EdgeTargetLikeTuple, attributes: EdgeAttributesObject, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(attributes: EdgeAttributesObject): void;\r\n    graph(attributes: SubgraphAttributesObject): void;\r\n}\r\n\r\n/**\r\n * Base class for Graph objects.\r\n * @group Models\r\n */\r\ndeclare abstract class GraphBase_3<T extends AttributeKey> extends AttributesBase_5<T> implements GraphBaseModel<T> {\r\n    #private;\r\n    readonly id?: string;\r\n    comment?: string;\r\n    readonly attributes: Readonly<GraphCommonAttributes>;\r\n    get nodes(): ReadonlyArray<NodeModel>;\r\n    get edges(): ReadonlyArray<EdgeModel>;\r\n    get subgraphs(): ReadonlyArray<SubgraphModel>;\r\n    with(models: Partial<ModelsContext>): void;\r\n    addNode(node: NodeModel): void;\r\n    addEdge(edge: EdgeModel): void;\r\n    addSubgraph(subgraph: SubgraphModel): void;\r\n    existNode(nodeId: string): boolean;\r\n    existEdge(edge: EdgeModel): boolean;\r\n    existSubgraph(subgraph: SubgraphModel): boolean;\r\n    createSubgraph(id?: string, attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    createSubgraph(attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    removeNode(node: NodeModel | string): void;\r\n    removeEdge(edge: EdgeModel): void;\r\n    removeSubgraph(subgraph: SubgraphModel): void;\r\n    createNode(id: string, attributes?: NodeAttributesObject): NodeModel;\r\n    getSubgraph(id: string): SubgraphModel | undefined;\r\n    getNode(id: string): NodeModel | undefined;\r\n    createEdge(targets: EdgeTargetLikeTuple, attributes?: EdgeAttributesObject): EdgeModel;\r\n    subgraph(id: string, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(id: string, attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    node(id: string, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(id: string, attributes: NodeAttributesObject, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(attributes: NodeAttributesObject): void;\r\n    edge(targets: EdgeTargetLikeTuple, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(targets: EdgeTargetLikeTuple, attributes: EdgeAttributesObject, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(attributes: EdgeAttributesObject): void;\r\n    graph(attributes: SubgraphAttributesObject): void;\r\n}\r\n\r\n/**\r\n * Base class for Graph objects.\r\n * @group Models\r\n */\r\ndeclare abstract class GraphBase_4<T extends AttributeKey> extends AttributesBase_8<T> implements GraphBaseModel<T> {\r\n    #private;\r\n    readonly id?: string;\r\n    comment?: string;\r\n    readonly attributes: Readonly<GraphCommonAttributes>;\r\n    get nodes(): ReadonlyArray<NodeModel>;\r\n    get edges(): ReadonlyArray<EdgeModel>;\r\n    get subgraphs(): ReadonlyArray<SubgraphModel>;\r\n    with(models: Partial<ModelsContext>): void;\r\n    addNode(node: NodeModel): void;\r\n    addEdge(edge: EdgeModel): void;\r\n    addSubgraph(subgraph: SubgraphModel): void;\r\n    existNode(nodeId: string): boolean;\r\n    existEdge(edge: EdgeModel): boolean;\r\n    existSubgraph(subgraph: SubgraphModel): boolean;\r\n    createSubgraph(id?: string, attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    createSubgraph(attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    removeNode(node: NodeModel | string): void;\r\n    removeEdge(edge: EdgeModel): void;\r\n    removeSubgraph(subgraph: SubgraphModel): void;\r\n    createNode(id: string, attributes?: NodeAttributesObject): NodeModel;\r\n    getSubgraph(id: string): SubgraphModel | undefined;\r\n    getNode(id: string): NodeModel | undefined;\r\n    createEdge(targets: EdgeTargetLikeTuple, attributes?: EdgeAttributesObject): EdgeModel;\r\n    subgraph(id: string, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(id: string, attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    node(id: string, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(id: string, attributes: NodeAttributesObject, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(attributes: NodeAttributesObject): void;\r\n    edge(targets: EdgeTargetLikeTuple, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(targets: EdgeTargetLikeTuple, attributes: EdgeAttributesObject, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(attributes: EdgeAttributesObject): void;\r\n    graph(attributes: SubgraphAttributesObject): void;\r\n}\r\n\r\n/**\r\n * Base class for Graph objects.\r\n * @group Models\r\n */\r\ndeclare abstract class GraphBase_5<T extends AttributeKey> extends AttributesBase_9<T> implements GraphBaseModel<T> {\r\n    #private;\r\n    readonly id?: string;\r\n    comment?: string;\r\n    readonly attributes: Readonly<GraphCommonAttributes>;\r\n    get nodes(): ReadonlyArray<NodeModel>;\r\n    get edges(): ReadonlyArray<EdgeModel>;\r\n    get subgraphs(): ReadonlyArray<SubgraphModel>;\r\n    with(models: Partial<ModelsContext>): void;\r\n    addNode(node: NodeModel): void;\r\n    addEdge(edge: EdgeModel): void;\r\n    addSubgraph(subgraph: SubgraphModel): void;\r\n    existNode(nodeId: string): boolean;\r\n    existEdge(edge: EdgeModel): boolean;\r\n    existSubgraph(subgraph: SubgraphModel): boolean;\r\n    createSubgraph(id?: string, attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    createSubgraph(attributes?: SubgraphAttributesObject): SubgraphModel;\r\n    removeNode(node: NodeModel | string): void;\r\n    removeEdge(edge: EdgeModel): void;\r\n    removeSubgraph(subgraph: SubgraphModel): void;\r\n    createNode(id: string, attributes?: NodeAttributesObject): NodeModel;\r\n    getSubgraph(id: string): SubgraphModel | undefined;\r\n    getNode(id: string): NodeModel | undefined;\r\n    createEdge(targets: EdgeTargetLikeTuple, attributes?: EdgeAttributesObject): EdgeModel;\r\n    subgraph(id: string, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(id: string, attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    subgraph(callback?: (subgraph: SubgraphModel) => void): SubgraphModel;\r\n    node(id: string, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(id: string, attributes: NodeAttributesObject, callback?: (node: NodeModel) => void): NodeModel;\r\n    node(attributes: NodeAttributesObject): void;\r\n    edge(targets: EdgeTargetLikeTuple, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(targets: EdgeTargetLikeTuple, attributes: EdgeAttributesObject, callback?: (edge: EdgeModel) => void): EdgeModel;\r\n    edge(attributes: EdgeAttributesObject): void;\r\n    graph(attributes: SubgraphAttributesObject): void;\r\n}\r\n\r\n/**\r\n * DOT object class representing a node.\r\n * @group Models\r\n */\r\nexport declare class Node extends DotObject_9 implements NodeModel {\r\n    readonly id: string;\r\n    get $$type(): 'Node';\r\n    comment?: string;\r\n    readonly attributes: AttributesGroup_2<NodeAttributeKey>;\r\n    constructor(id: string, attributes?: NodeAttributesObject);\r\n    port(port: string | Partial<Port>): ForwardRefNode;\r\n}\r\n\r\nexport declare function registerDefault(): void;\r\n\r\n/**\r\n * Base class representing a root graph(digraph, graph).\r\n * @group Models\r\n */\r\nexport declare abstract class RootGraph extends GraphBase_4<GraphAttributeKey> implements RootGraphModel {\r\n    get $$type(): 'Graph';\r\n    readonly id?: string;\r\n    abstract readonly directed: boolean;\r\n    strict: boolean;\r\n    constructor(id?: string, attributes?: GraphAttributesObject);\r\n    constructor(id?: string, strict?: boolean, attributes?: GraphAttributesObject);\r\n    constructor(strict?: boolean, attributes?: GraphAttributesObject);\r\n    constructor(attributes?: GraphAttributesObject);\r\n}\r\n\r\n/**\r\n * Base class representing a root graph(digraph, graph).\r\n * @group Models\r\n */\r\ndeclare abstract class RootGraph_2 extends GraphBase_2<GraphAttributeKey> implements RootGraphModel {\r\n    get $$type(): 'Graph';\r\n    readonly id?: string;\r\n    abstract readonly directed: boolean;\r\n    strict: boolean;\r\n    constructor(id?: string, attributes?: GraphAttributesObject);\r\n    constructor(id?: string, strict?: boolean, attributes?: GraphAttributesObject);\r\n    constructor(strict?: boolean, attributes?: GraphAttributesObject);\r\n    constructor(attributes?: GraphAttributesObject);\r\n}\r\n\r\n/**\r\n * Base class representing a root graph(digraph, graph).\r\n * @group Models\r\n */\r\ndeclare abstract class RootGraph_3 extends GraphBase_3<GraphAttributeKey> implements RootGraphModel {\r\n    get $$type(): 'Graph';\r\n    readonly id?: string;\r\n    abstract readonly directed: boolean;\r\n    strict: boolean;\r\n    constructor(id?: string, attributes?: GraphAttributesObject);\r\n    constructor(id?: string, strict?: boolean, attributes?: GraphAttributesObject);\r\n    constructor(strict?: boolean, attributes?: GraphAttributesObject);\r\n    constructor(attributes?: GraphAttributesObject);\r\n}\r\n\r\n/**\r\n * DOT object class representing a subgraph.\r\n * @group Models\r\n */\r\nexport declare class Subgraph extends GraphBase_5<SubgraphAttributeKey | ClusterSubgraphAttributeKey> implements SubgraphModel {\r\n    get $$type(): 'Subgraph';\r\n    readonly id?: string;\r\n    constructor(id?: string, attributes?: SubgraphAttributesObject);\r\n    constructor(attributes?: SubgraphAttributesObject);\r\n    isSubgraphCluster(): boolean;\r\n}\r\n\r\nexport { }\r\n"},{"filePath":"file:///node_modules/@ts-graphviz/core/lib/register-default.d.ts","content":"export declare function registerDefault(): void;\r\n\r\nexport { }\r\n"}]
